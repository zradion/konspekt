<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="../css/style1.css" />
    <title>libraryPy</title>
</head>
<body>
  <div class="cont">
    <div class="left_right">
      <aside class="left">
    <p><a href="../index.html"><img src="../img/icon-home.png" alt="home"></a></p>
    <p><a href="#s0"><img src="../img/arrow-top.png" alt="arrow-top"></a></p>
  
    <p><a href="#s1">random</a></p>
    <p><a href="#s2">sys</a></p>
    <p><a href="#s3">copy</a></p>
    <p><a href="#s4">pyperclip</a></p>
    <p><a href="#s5">math</a></p>
    <p><a href="#s6">shelve</a></p>
    <p><a href="#s7">pickle</a></p>
    <p><a href="#s8">pprint</a></p>
    <p><a href="#s9">pyinputplus</a></p>
    <p><a href="#s10">Время</a></p>
    <p><a href="#s11">Regex</a></p>
    <p><a href="#s12">Pandas</a></p>
    <p><a href="#s13">NumPy</a></p>
    <p><a href="#s14">TeX</a></p>
    <p><a href="#s15">pywin32</a></p>
    <p><a href="#s16">threading</a></p>
    <p><a href="#s17">geocoder</a></p>
    <p><a href="#s99">Ссылки.</a></p>            
      </aside>
    
      <aside class="right"><h1 align="center" id="s0">Library for Python.</h1>

  <section id="s1"> <b>import random</b><br>

<i>random.randint(a, b)</i> - случайное число от a до b, включая оба<br>
<i>random.choise([list])</i> - слуачайное значение из списка<br>
<i>random.choice(list(range(20)))</i> - случайное из 20<br>
<i>random.shuffle(list)</i> - перемешать список (на месте)<br>
<i>a = random.sample(list, 3)</i> - вернёт список из трёх рандомных значений<br>
<i>random.uniform(0,1)</i> - число от 0 до 1<br>
  </section>  

  <section id="s2"> <b>import sys</b><br>

<i>sys.exit()</i> (Try, except; Ctrl+c - выход без выброса ошибки)<br>
  </section>

  <section id="s3"> <b>import copy</b><br>

копирование объектов<br>
<i>copy.copy(test)</i> - поверхносная копия<br>
<i>copy.deepcopy(test)</i> - глубокое копирование<br>
  </section>

  
  <section id="s4"> <i>pip install pyperclip;</i> <b>import pyperclip</b><br>

pyperclip.copy('Hello, world')<br>
pyperclip.paste()<br>
  </section>

  <section id="s5"> <b>import math</b><br>

math.pi<br>
math.ceil(5.2) .. 6<br>
math.floor(5.99) .. 5<br>
.sqrt(); .sin(); .cos();<br>
  </section>


  <section id="s6"> <b>import shelve</b><br>

сохранить как бинарные файлы; появятся три файла с расширениями <i>.bak, .dat, .dir</i>;<br>
open(path[, flag='c'[, protocol=None[, writeback=False]]])<br>
<i>c</i> (по умолчанию) - чтение и запись<br>
<i>r; w</i> - только для чтения или записи<br>
<i>n</i> - для записи создаётся или перезаписывается<br><br>

shelfFile = shelf.open('mydata') - принемает строку (не Path obj)<br>
cats = ['Zophie', 'Poork', 'Simon']<br>
shelfFile['cats'] = cats - сохранить как словарь по ключу<br>
shelfFile.close()<br><br>

shelfFile = shelf.open('mydata') <br>
shelfFile['cats'] .. ['Zophie', 'Poork', 'Simon']<br>
list(shelfFile.keys()) .. ['cats']<br>
list(shefFile.values()) .. [['Zophie', 'Poork', 'Simon']]<br>
shelfFile.close()<br><br>

with shelve.open('mydata') as shelve_f:<br>
&nbsp;&nbsp;&nbsp;&nbsp;if 'cats' in shelve_f:
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; print(cats = shelve_f['cats'])<br><br>

для перебора всех ключей используем цикл.<br>
метод keys() - верёт все ключи; метод values() - все значения; items() - набор кортежей<br>
pop(key, value) - удалит и вернёт ключ и значение по умолчанию (если ключ на найден)<br>
del shelve_f['key'] - удалить<br>
shelve_f.clear() - удалить всё<br>
  </section>

  <section id="s7"> <b>import pickle</b><br>

к режиму записи или чтения добавляем <i>'b'</i> ("wb", "rb")<br>
<i>dump(obj, file)</i> - записывавет объект в бинарный файл.<br>
<i>load(file)</i> - считывает данные из бинарного файла в объект.<br><br>

name = "Tom"; age = "19"<br>
with open("user.dat", "wb") as file:<br>
&nbsp;&nbsp;&nbsp;&nbsp; pickle.dump(name, file)<br>
&nbsp;&nbsp;&nbsp;&nbsp; pickle.dump(age, file)<br><br>

with open("user.dat", "rb") as file:<br>
&nbsp;&nbsp;&nbsp;&nbsp; name = pickle.load(file)<br>
&nbsp;&nbsp;&nbsp;&nbsp; age = pickle.load(file)<br>
&nbsp;&nbsp;&nbsp;&nbsp; print('Name: ', name, 'Age: ', age)<br><br>

users = [['Tom', 34, True], ['Alice', 23, False]]<br>
with open('users.dat', 'wb') as file:<br>
&nbsp;&nbsp;&nbsp;&nbsp; pickle.dump(users, file)<br><br>

with open('users', 'rb') as file:<br>
&nbsp;&nbsp;&nbsp;&nbsp; usersF = pickle.load(file)<br>
&nbsp;&nbsp;&nbsp;&nbsp; for user in usersF:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; print(f"Name {user[0]}, age: {user[1]}, married: {user[2]})<br>
    </section>

  <section id="s8"> <i>pip install pprint</i>; <b>import pprint</b><br><br>
<i>pprint.pprint</i> - печать списков<br>
<i>pprint.pformat</i> - вернёт текст в виде строки<br><br>

with open('myCats.py', 'w') as file:<br>
&nbsp;&nbsp;&nbsp;&nbsp;file.write('cats = ' + pprint.pformat(cats) + '\n' ) # записали в файл с расширением .py список словарей <br>
теперь можно вызвать import myCats; myCats.cats - вернёт список; к папке с файлом должен быть путь в 'переменных среды'<br>
  </section>

  <section id="s9"> <i>pip install pyinputplus</i><br>
<b>import pyinputplus as pyip</b><br><br>

<i>inputStr()</i><br>
<i>inputNum()</i> min=None, greaterThan=None, lessThan=None<br>
<i>inputChoice()</i><br>
<i>inputMenu()</i><br>
<i>inputDatetime()</i><br>
<i>inputYesNo()</i><br>
<i>inputBool()</i><br>
<i>inputEmail()</i><br>
<i>inputFilepath()</i><br>
<i>inputPassword()</i><br>
  </section>

  <section id="s10"><h3 align="center">Время</h3>

UTC - Coordinated Universal Time<br>
EST, EDT - восточное, западное побережье Америки.<br>
Unix epoch - начало эпохи (1970, 1, 1, 12, 0, 0)<br><br>

<b>import time</b><br>
t = <i>time.time()</i> - без аргумента; привязана к системным часам; время в секундах с начала эпохи(1970-01-01 0:00:00 utc)<br>
Дальше можно подставлять аргумент (секунды)<br>
<i>time.gmtime()</i> ..time.struct_time(tm_year=2023, tm_mon=10, tm_mday=6, tm_hour=13, tm_min=28, tm_sec=59, tm_wday=4, tm_yday=279, tm_isdst=0)<br>
<i>time.localtime()</i> ..time.struct_time(tm_year=2023, tm_mon=10, tm_mday=6, tm_hour=16, tm_min=29, tm_sec=13, tm_wday=4, tm_yday=279, tm_isdst=0)<br>
<i>time.ctime()</i> - Thu Aug 31 15:52:18 2023<br>
local = dt.datetime.fromtimestamp(t)<br>
zone = dt.timezone(dt.timedelta(seconds=abs(time.timezone))) ..10800сек (3часа)<br>
local = dt.datetime.fromtimestamp(t, zone) ..2023-10-06 17:00:48.587647+03:00<br>
<i>time.sleep(1)</i> - задержка 1с<br><br>

start_time = <i>time.monotonic()</i> - замеряем время от start_time.<br>
print(f"Прошло {time.monotonic() -  start_time}")<br><br>

<b>import datetime as dt</b><br>
Классы: date, time, datetime<br>
<i>.date</i><br>
date(year, month, day)<br>
print(dt.date(2023,8,31)) .. 2023-08-31 (изоформат)<br>
today = dt.date.today() .. 2023-08-31<br>
print(f"{today.day}.{today.manth}.{today.year}") .. 31.8.2023<br><br>

today.replace(day=20) - изменит только в новой переменной.<br><br>

<i>.time</i><br>
time([hour][, min][, sec][, microsec]) (без параметров 0:0:0)<br>
print(dt.time(10,47,20)) .. 10:47:20<br><br>

<i>.datetime</i><br>
datetime(year, month, day [, hour][, min][, sec][, microsec])<br>
print(dt.datetime(2023,8,31)) .. 2023-08-31 00:00:00<br>
now = dt.datetime.now()<br> ..2023-08-31 10:58:03.968252<br>
now.date; now.month; now.year; now.hour, now.minute, now.microsecond, now.day_name<br>
ts = dt.datetime.timestamp(now) ..1696590800.965508<br>
dt.datetime.fromtimestamp(ts).date() .. 2023-10-06<br><br>

<i>strptime(str, format)</i> - распарсить строку; преобразовать в дату<br>
%d; %m; %y; %Y; %H; %M; %S - день; номер месяца; год (две цифры); год (4 цифры); час; минута; секунда<br>
deadline = dt.datetime.strptime("05-22-2017 12:30", "%m-%d-%Y %H:%M")<br>
print(deadline) .. 2017-05-22 12:30:00<br>
print(deadline.date()) ..2017-05-22<br><br>

<i>strftime(format)</i> - для объектов <i>date</i> и <i>time</i>; принимает один параметр - формат<br>
%a - Wed; %A - Wednesday; %b - Oct; %B - October<br>
%d - 01(день); %m - 05(месяц); %y - 23; %Y - 2023<br>
%H - 13(часов); %I - 01(час); %M; %S; %f - микросекунда<br>
%p - AM/PM; %c - дата и время местный формат<br>
%x; %X - дата; время - местный формат<br>
print(now.strftime("%d %b (%A)")) .. 31 Aug (Thursday)<br><br>

<i>import locale</i><br>
<i>locale.setlocale(locale.LC_ALL, "")</i> - для использования русских(местных) слов<br><br>

<i>dt.timedelta([days][, seconds][, microseconds][, milliseconds][, minutes][, hours][, weeks])</i> - класс;<br>
now + dt.timedelta(days=100) .. плюс сто дней от now<br><br>

three_hours = dt.timedelta(hours=3, minutes=25) .. 3:25:00<br>
two_days = dt.timedelta(2, 25) .. 2 days, 0:00:25<br>
delta = three_hours + two_days .. 2 days, 3:25:25<br><br>

методы: <i>days, seconds, microseconds, total_seconds()</i><br>
delta.seconds; delta.total_seconds()<br><br>

if now > deadline:<br>
&nbsp;&nbsp;&nbsp;&nbsp;print("Time is over")<br>
elif now.day == deadline.day and now.month == deadline.month:<br>
&nbsp;&nbsp;&nbsp;&nbsp;print("today")<br>
else:
&nbsp;&nbsp;&nbsp;&nbsp;period = deadline - now<br>
&nbsp;&nbsp;&nbsp;&nbsp;print(f"осталось {period.days} дней")<br>
  </section>

  <section id="s11"><h3 align="center">Regex</h3>

    <b>import re</b><br>
Regular expressions (regexes)<br>
Специальные символы: <b>\ . $ ? + * {} [] () | </b> - надо экранировать (\) или использовать сырую строку (r"txt")<br>
pattern = <i>re.compile</i>(r'\d{3}) - pattern передаём в  re.compile() и сохраняем в regex object<br>
result = <i>re.match</i>(r"word", txt) - только в начале строки<br>
result = <i>pattern.search</i>(txt).group()<br>
result = <i>re.search</i>(r"word", txt)[0] - первое совпадение<br>
print(result[0] if result else 'NO')<br><br>

<i>re.fullmatch</i>(pattern, string) - проверить полное совпадение под шаблон<br>
print('Yes' if result else 'No')<br>
re.search, re.fullmatch - возвращают match-объект или None<br>
<i>result.group() или result[0]</i> - всё совпадение; в скобках можно указать группу или группы через зпт<br>
<i>result.group<b><ins>s</ins></b>()</i> - вернёт кортеж из всех групп; можно исп множественное присвоение для разных частей патерна<br>
<i>result.start(), result.end(), result.lastindex</i> - позиция начала совпадения, следующий после, последний индекс группы(кол-во групп); в скобках номер групы; если не находит -1<br>
<i>result.span(0)</i> - кортеж начальной и конечной позиции.<br>
<i>result.re </i>- компелированный шаблон.<br>
<i>result.string </i>- анализируемая строка.<br><br>

text = "&lt;font color=#CC0000>"<br>
result = re.search(r"(?P&lt;key>\w+)=(?P&lt;volue>#[\da-fA-F]{6})\b", text) - именованые группы key and volue.<br>
<i>result.groupdict()</i> .. {'key': 'color', 'volue': '#CC0000'}<br>
result.expand(r"\g&lt;key> :\g&lt;volue>") .. color: #CC0000<br>
<i>result.expand</i>(r"\1 :\2") .. color: #CC0000<br><br>

<i>re.findinter</i> - то же, что и search, только исп в циклах для нахождения всех совпадений.<br><br>

Сохраняющие скобки (при search, fullmatch and finditer) не изменяют вывод, но можно получить инфо по каждой группе (если не используется квантификатор; тогда только для последнего соответсвия).<br>
Нумерация в группах: pattern = r"((\d)(\d))((\d)(\d))<br>
0 - весь шаблон; 1 - первые две цифры; 2 - первая цифра; 3 - вторая; 4 - вторые две цифры; 5 - третья цифра; 6 - четвёртая<br>
match = re.search(r"\s*([А-Яа-яЁё]+)(\d+)\s*", r"--Опять45--")<br>
print(match[0], <i>match.start</i>(0), <i>match.end</i>(0)) - весь шаблон<br>
print(match[1], match.start(1), match.end(1)) - первая группа<br>
print(match.group(1,2,3)) - кортеж из групп<br><br>

<i>re.split</i>(pattern, string, maxsplit=0) - разделение по подстрокам, подходящим под шаблон<br>
print(re.split(r"\W+", "Где скажите мне, мои очки?"))
... ["Где", "скажите", "мне", "мои", "очки"]<br>

<i>re.findall</i>(pattern, string) - вернёт список строк, если нет групп и список кортежей, если есть (все непересекающиеся шаблоны).<br>
result = re.findall(r"стеклянн?ый", text) - вернёт список всех совпадений.<br>
result = re.findall(r"(\w+)\s*=\s*([^;]+)", text) - группа букв.цифр до ,возможно, прбелов; потом =; возможно пробелы; любые символы кроме ';'<br>
print(result)<br><br>

<i>re.finditer</i>(pattern, string) - итератор по непересекающимся шаблонам<br><br>

<i>re.sub</i>(pattern, repl, string, count=0) - заменить все непересекающиесся шаблоны на repl<br>
result2 = re.sub(r"old", r"new", txt) - заменить<br>
второй аргумент может быть имя ф-ции.<br><br>

text = "Moscow Saint-Petersburg Novgorod"<br>
result2 = re.sub(r"\s*[\w-]+\s*", r"&lt;option>\1&lt;/option>\n", text)<br>
print(result2)<br><br>

count = 0<br>
def replFind(m): # аргумент - объект Match<br>
&nbsp;&nbsp;&nbsp;&nbsp; global count<br>
&nbsp;&nbsp;&nbsp;&nbsp; count += 1<br>
&nbsp;&nbsp;&nbsp;&nbsp; return f"&lt;option value='{count}'>{m.group(1)}&lt;/option>\n"<br>
result2 = re.sub(r"\s*[\w-]+\s*", replFind, text)<br>
.. &lt;option value='1'>Moscow&lt;option>...<br><br>

Использование групп при замене:<br>
Можно ссылаться на соответсвующую группу при помоощи \1, \2, ...(если групп больше 9, то \g<12>)<br>
print(re.sub(r"(\d\d)/(\d\d)/(\d{4})", r"\2.\1.\3", "03/25/2023")) - дата по амер; вернёт в нормальном порядке через точку<br><br>


Символьные классы: [A-z][0-9] // одна буква и одна цифра; спец символы здесь не работают(кроме \)<br>
<table>
  <tr><td><b>.</b></td><td>любой символ; кроме \n; с флагом re.DOTALL - весь текст (wildcard)</td></tr>
  <tr><td><b>\d</b></td><td>любая цифра [0-9]</td></tr>
  <tr><td><b>\D</b></td><td>любой не цифровой символ [^0-9]</td></tr>
  <tr><td><b>\s</b></td><td>любой пробельный символ [\t\n\r\f\v]</td></tr>
  <tr><td><b>\S</b></td><td>любой непробельный символ</td></tr>
  <tr><td><b>\w</b></td><td>буквы и цифры, знак подчёрк [a-zA-Z0-9] (\w+ выберет слова)</td></tr>
  <tr><td><b>\W</b></td><td>не буквы и цифры [^а-яА-Я0-9Ёё]</td></tr>
  <tr><td>  </td></tr>
  <tr><td><b>|</b></td><td>или</td></tr>
  <tr><td><b>\b</b></td><td>граница слова</td></tr>
  <tr><td><b>^</b></td><td>отрицание для символьного класса или начало строки</td></tr>
  <tr><td><b>$</b></td><td>конец строки</td></tr>
  <tr><td><b>\A</b></td><td>начало текста</td></tr>
  <tr><td><b>\B</b></td><td>отсутствие границы слова</td></tr>
  <tr><td><b>\Z</b></td><td>конец текста</td></tr>
  <tr><td><b>(?:exp)</b></td><td>не сохраняющие скобки</td></tr>
  <tr><td><b>(?=exp)</b></td><td>проверка на совпадение</td></tr>
  <tr><td><b>(?!exp)</b></td><td> проверка на несовпадение</td></tr>
  <tr><td><b>(?&lt;=exp)</b></td><td>проверка на совпадение ретроспективная</td></tr>
  <tr><td><b>(?&lt;!exp)</b></td><td> проверка на несовпадение ретроспективная</td></tr>
</table><br>

match = re.findall(r"^&lt;script.*?>([\w\W]+)(?=&lt;/script>)", text, re.MULTILINE) - взять содержимое тега script (без самого script); [\w\W] - что бы вошёл символ переноса строки<br><br>

match = re.findall(r"([-\w]+)[ \t]*=[ \t]*[\" ']([^\" ']+)(?&lt;![ \t])", text, re.MULTILINE) - пары ключ, значение; ключ - символы, дефис; пробел или табуляция; равно; пробел или табуляция; ковычки; содержимое значения(до не кавычки); ретроспективная проверка на наличие пробела или табуляции (не вкл)<br><br>

<i>Квантификаторы</i><br>
 {m} - повторений; {mix,max}; {min,}; {,max}!<br>
 жадные(мажорные, greedy) - по максимуму, нежадные(минорные, non-greedy) {2,5}? <br>
 <b>?</b> - {0,1} re.findall(r"стеклянн?ый")<br>
 <b>*</b> - {0,}<br>
 <b>+</b> - {1,}<br><br>

 text = &lt;p> Pic &lt;img='bg.jpg'> in text&lt;/p> <br>
 match = re.findall(r"&lt;img.*?>", text) - нежадный поиск (до первой скобки)<br>
 match = re.findall(r"&lt;img[^>]*>", text) - то же<br><br>

 text = "lat=5, lon=3"<br>
 match = re.findall(r"(?:lat|lon)\s*=\s*(\d+)) - или lat или lon в несохраняющих скобках .. ['lat=5', 'lon=3']<br>
 match = re.findall(r"(lat|lon)\s*=\s*(\d+)") - сохраняющие скобки ..[('lat', '5'), ('lon', '3')]<br><br>

 (?P<name>...) (?P=name) именованые сохраняющие скобки<br>

 <b>flags:</b><br>
 <i>re.A (re.ASCII)</i><br>
 <i>re.I (re.IGNORCASE)</i> - без учёта реистра символов.(case-insensitive)<br>
 <i>re.M (re.MULTILINE)</i> - влияет на проверки ^, $(с начала строки)<br>
 <i>re.S (re.DOTALL)</i> - ищет по всему тексту<br>
 <i>re.X (re.VERBOSE)</i> - позволяет вкл коментарии. <br>
 <i>re.DEBUG</i> - режим отладки.<br><br>

 Флаги можно комбинировать с помощью пайп (pipe) "|"<br>
 match = re.findall(r"(?im)python", text) - включить флаги в шаблон<br><br>

 <p><a href="https://habr.com/ru/articles/349860/" target="_blank" rel="noopener" >ShashkovS</a> - регулярные выражения</p>
 <p><a href="https://proproprogs.ru/modules/literaly-i-simvolnyy-klass" target="_blank" rel="noopener" >proproprogs</a> - регулярные выражения</p>
 <p><a href="https://docs.python.org/3/library/re.html" target="_blank" rel="noopener" >The Python Tutorial</a> - Python 3.11.4 documentation</p>
 <p><a href=" https://www.regular-expressions.info/" target="_blank" rel="noopener" >regular-expressions</a> - подробный материал</p>
  </section>

  <section id="s12"><h3 align="center">Pandas</h3>

<i>pip insall pandas</i>; <b>import pandas as pd</b><br><br>

<b>Конструктор</b><br>
mySeries = pd.Series(my_dict)<br>
..type(mySeries) ..class 'pandas.core.series.Series'<br><br>

<i>df = pd.DataFrame(data, columns=[list], index=[list])</i><br> 
..&lt;class 'pandas.core.frame.DataFrame'></class><br><br>

data - список списков, словарь, список словарей<br>
data = {'a':[list], 'b':[list]} ключи - назв.колонок, списки - значения(колонки)<br>
data = [['Alex', 10], ['Bob', 12], ['Clar', 13]]- список строк, две колонки(стр)<br>
data = [{dict1}, {dict2}] - каждый словарь - строка<br>
data = {'a':{'1': 'a1', '2': 'a2'}, 'b':{'1': 'b1', '2': 'b2'}} - словари со вложеными; a - назв.столбцов, '1'- индекс; 'a1' - значение<br>
df = pd.DataFrame([Series1, Series2]) - две строки в df<br><br>

один столбец представляется как Series; чтобы получить df надо применить к ней .reset_index() или подставить в конструктор pd.DataFrame(Series)<br><br>

<b>Прочитать, выгрузить в другой формат</b><br>
df = pd.read_csv(path, index_col='date', sep=';') - индексами сделать 'date'
   sep- разделитель, header=None, skiprow=[0,1,3], usecols=None,
   encoding='1251', na_values = ['NA', 'Missing'] (заменить значения на пустые)<br>
d_parser = lambda x: pd.datetime.strptime(x, '%Y-%m-%d %I-%p')<br>
df = pd.read_csv(path, parse_dates=['date'], date_parser=d_parser) - 'date' - Dtype - datetime64[ns]
    (index_col='date', parse_dates=True)<br>
df = pd.read_csv(path, usecols=[], nrows=100) - выбрать колонки и кол-во строк/вывода<br>
custom_datetime = lambda x: datetime.strptime(x, '%d%m%Y %H:%M:%S')<br>
df = pd.read_csv('тест2.csv', parse_dates=['date'], date_parser=custom_datetime)<br><br>

df = pd.read_excel(path, engine='odf', sheet_name='вещи', index_col='Дата')<br>
df.to_excel(path) - сохранить в таблице (один лист)<br>
для записи нескольких листов: writer = pd.ExcelWriter('table.ods', engine='odf', date_format=None, datetime_format=None, mode='w'('a'), storage_options=None, if_sheet_exists=None, engine_kwargs=None)<br>
df1.to_excel(writer, sheet_name='name1'); writer.save()<br><br>

with pd.ExcelWriter("my_table.ods", engine='odf') as writer:<br><br>

df = pd.read_sql_query(query, db)<br><br>

df.rename(index={'old': 'new'}, columns={'old': 'new'}, inplace=True)<br>
df.describe() - статистики по столбцам<br>
pd.options.mode.chained_assignment = None <br>
df.fillna(0, inplace=True) - заменим пропуски данных нулями<br><br>

col_names = [список новых заголовков]<br>
data = pd.read_csv(path, names=col_names, skiprows=[0]) - новые заголовки,
строку со старыми пропустить<br>
skiprows = [0,3,5] - пропустить указанные строки<br>
header= None, skiprows=[0] -  удалить заголовки<br><br>

Поменять в столбце "вид" название растений на цифры<br>
lablel_encode = {'вид': {'iris0': 0, 'iris1': 1, 'iris2': 2}}<br>
df1 = df.replace(label_encode)<br><br>

df['date'] = pd.to_datetime(df[date], format="%Y-%m-%d %I-%p", errors='ignore')<br>
df['date', 'start'] = df[['date', 'start']].apply(pd.to_datetime) - два столбца<br><br>

df.info() - кол-во строк(entries), индексы, название колонок, кол-во знач в них<br>
df.shape - кортеж (tupl) кол-во строк, кол-во колонок<br>
df.size - кол-во клеток в таблице<br>
df.T - transpose - меняет строки и столбцы местами<br>
df.dtypes - назв. колонок и тип данных в каждой<br>
df.values - список списков всех данных<br>
df.columns - список колонок<br>
df.index -  список индексов<br>
df.axes - список индексов и колонок<br>
df.head() - начало df<br>
df.tail() - конец df<br>
df.sample() - случайные строки<br><br>

df['reveneu'].nlargest(10) - 10 самых больших значений (Series).<br>
df.nlargest(10, 'revenue') - 10 строк (df).<br>
.nsmallest() - наименьшие.<br>

df.loc['name_str', 'name_column']<br>
df.loc[1] - первая строка Series<br>
df.loc[1:], df.loc[:5], df.loc[2:4], df.loc[[2,5], ['km', 'l']]<br>
df.loc[[5]] - строка по индексу DataFrame<br>
df.iloc[5], df.iloc[0,5] - по цифровому индексу [строка,колонка]<br>
df.loc[len(df)-1] - последняя строка Series<br>
df.loc[len(df)-1, ['data', 'note']] - посл. строка в двух колонках<br>
df.loc[:, 'name_column'] - весь сттолбец<br>
df.loc[:, ['name1', 'name2']] - два столбца<br>
df.loc[:, 'name1':'name2'] - несколько столбцов подряд<br>
df.iloc[[1,3]] - первая и третья строка<br><br>

df['name_columns'], df.name_columns - колонка Series<br>
df[2:4] - сокращённое две строки df<br><br>

<b>Индексы</b><br>
df.reset_index(inplace=True) - индексы стали первым столбцом<br>
df.reset_index(drop=True, inplace=True)- переустановить индексы<br>
df.set_index('month', inplace=True) - столбец 'month' стал индексами<br>
df = pd.read_csv(path, index_col='month') - прочитать csv 'month' - индексы<br>
df.to_csv(path, index_label='month') - сохран. в csv столбец индексов с именем<br>
df.svechi.dropna().index - список индексов соотв. не пустым знач. в 'svechi'<br>
df.svechi.dropna().index [-1] -  последний индекс в списке<br>
df.index[df.svechi == 206795]  - индекс значения 206795<br>
df.sort_index()<br>
df.rename(index={'old': 'new'}, inplace=True)<br>
df.index = [список новых индексов]<br>
df.index.names = ['month'] - переименовали колонку с индексами<br><br>

<b>Столбец</b><br>
df = pd.read_csv(path, names=[list], skiprows=[0])- поменяли заголовки,
     оригинальные пропустили<br>
df['name_column'] - столбец в Series (df.name_column)<br>
df[['name1', 'name2']] - несколько столбцов<br>
df.astype({'name_column': 'int'}) - преобразовать тип данных в столбце<br>
df.name.dropna() - вызвать стобец 'name' без пустых значений<br>
subset =[] -  аргумент в котором указываются столбцы в которых искать<br>
df.rename(columns={'name1': 'new_name1'}, inplace=True) - переименовать<br>
df = df[['b', 'c', 'a', 'd']] - поменять порядок столбцов<br>
df.columns = ['name1', name2...nameN] - переименовать список столбцов<br>
df['new_name'] = [1,2,3] - новый столбец и значения соответсвуют кол. строк<br>
    одно значение  - повторится во всех строках<br>
df.insert(2, 'Team', [list values]) - (индекс колонки перед которой вставляем,
    название, данные)<br><br>

df.date = pd.DatetimeIndex(df.date) - столбец date - формат времени<br>
df.age = df['age'].astype(float) - пустые знач только в float<br>
df = df.astype({'price': 'int', 'usdprice': 'float'})<br>
del df['name_column']                                   - удалить столбец<br>
df.drop(['name_column'], axsis=1, inplace=True)         - удалить столбец<br>
df = df.drop(['name1_column', 'name2_column'], axis=1)  - удалить столбец<br>
df.pop('name_column')                                   - удалить столбец<br>
df.groupby('Cluster').mean() - сгрупировали по столбцу Cluster и посчитали
  среднее значение<br>
df.loc[df.Name == 'Bob'] - все строки с именем Bob<br>
df.loc[df.Name == 'Bob', 'Name'] = 'Kat' - в столбце Name заменили имя<br>
<i>and</i> - <b>&</b>; <i>or</i> - <b>|</b>; <i>not</i> - <b>~</b><br><br>

room3 = df.room3<br>
room3.loc[room3 > 100] - в столбце room3 значения больше 100<br><br>

df.names.unique() - уникальные значения в столбце names<br>
df.names.value_counts() - кол-во разных значений; аргумент [normalize=True] - в долях от общего кол-ва.<br>
.isnull() - возвращает True or False<br>
.sum() - суммирует<br>
df.room.isnull().sum()<br>
.fillna(0) - заменить пустые значения на указаное<br>
df.name = df['name'].fillna('unknown') - заменить значения в столбце<br>
.dropna(self, axis=0, how='any'(all - если все значения пропущены), thresh=None, subset=None(исключение для столбцов), inplace=False) - пропустить все пустые <br>
.duplicated()<br>
.drop_duplicates(inplace=True)<br>
.replace(name1, name2)<br>
df['room'].min(); df['room'].max()<br><br>

tenis.name = tenis.name.replace('Roger', 'Robert')<br>
label_encode = {'column_name': {'iris0': 0, 'iris1': 1}}<br>
df1 = df.replace(label_encode)<br>
df[name].count() - посчитать количество элементов<br>
df[name].value_counts() - посчитать кол-во каждого элемента<br>
x = iris.iloc[:,:-1].values - список списков - значения 4 из 5 столбцов<br><br>

<b>Строки</b><br>
df.loc['May'] = [list] - изменить/создать строку с индексом 'May'<br>
df.loc[len(df)] - последняя строка<br>
df.loc['name']  - строка с именем<br>
df.append({'A': 'bar', 'B': 4}, ignor_index=True)<br>
df.append(pd.Series(['bar', 4], index=['A', 'B'], ignor_index=True))<br>
df = df.drop(1, axis=0) - удалить первую строку<br>
df.drop('name_index',axis=0, inplace=True) - удалить строку<br>
df.drop(df.tail(1).index, inplace=True) - удалить последнюю строку<br><br>

line = pd.DataFrame({dict}, index=[3]) - вставить строку<br>
df2 = concat([df.iloc[:2], line, df.liloc[3:]].reset_index(drop=True))<br>

line = pd.DataFrame({dict}, index=[2,5])<br>
df2 = df.append(line, ignor_index=True)<br>
df2 = df2.sort_index().reset_index(drop=True)<br><br>

третий способ вставить строку<br><br>

<b>Сортировка</b><br>
df.sort_values(by='name_column, or list columns', ascending=False, inplace=False, <br>
kind='quicksort', no_position='last', ignore_index=False, key=None)
ascending - по возрастанию<br>
kind= [quicksort, mergesort, heapsort]<br>
key = любая ф-ция<br>
df.sort_values(by=['date', 'start'], ascending=[True, False], inplace=True)<br><br>
 
df = pd.concat([df1, dff2], ignore_index=True) - индексы(цифры) переустановить<br>
 
set_option<br>
pd.set_option('display.max_rows', None)<br>
pd.set_option('display.max_columns', None)<br>
pd.set_option('display.max_colwidth', None)<br><br>

<b>Время</b><br>
<i>NaT</i> - not a time; эквивалент NaN<br>
pd.Timestamp("2023") - 2023-01-01<br>
df.reset_index(inplace=True) - индексы в первую колонку<br>
df['date'] = pd.to_datetime(df['date'], dayfirst=True)<br>
df['date'] = pd.to_datetime(df['date'], format="%Y %B %d")<br>
df.sort_values(by='date', inplace=True)<br>
df.to_csv(path, index=False) - сохранить без столбца индексов<br>
df.set_index('date', inplace=True) - date индексы<br>
df.date['2021-01':'2021-02-25'] - срез по индексам (всё включено)<br>
avto.dayOfWeek = avto.date.dt.day_name() - новый столбец с днями недели<br>
.min(), .max()<br> 
avto.loc[avto.date>='2023'] - фрейм за 2023 год<br>
filt = (avto.date >= '2020') & (avto.date &lt; '2021')<br>
filt - (avto.date >= pd.to_datetime('2020-01-01'))<br>
highs = avto['revenue'].resample('m').max() - выборка по месяцам (список обозначений в документации)<br>
highs['2021-01-01'] - выбор по индексу.<br><br>

<b>Диапазон дат</b><br>
pd.date_range(start=datetime(year=2020, month=1, day=1), <br>
periods=30,
freq='D')   ...   DatetimeIndex(['2020-01-01', '2020-01-02', ... '2020-01-30'])<br>
date = pd.date_range('1/1/2022', periods=5, freq='H')<br>
DatetimeIndex(['2022-01-01 00:00:00', ...  '2022-01-01 05:00:00'])<br>

df = pd.concat([df1, df2], ignor_index=True) - восстановить порядок индексов<br><br>

<b>update</b>:<br>
обновит только существующие колонки или строки (лишнее игнорирует)<br>
df = pd.DataFrame(dict(A=[1,2,3], B=[4, 5, 6], C=[7, 8, 9]))<br>
new_column = pd.Series([40, 50], name='B', index=[0, 1])<br>
df.update(new_column) ... обновит стобец "В" два значения<br><br>

new_df = pd.DataFrame(dict(B=[40, 50]), index=[0,1])<br>
new_df = pd.DataFrame(dict(B=[40, 50, np.nan]))<br>
df.update(new_df) ... обновит стобец "В" два значения<br><br>

<b>Join</b><br>
DataFrame.join(self, other, on=None, how='left', \
                lsuffix='', rsuffix='', sort=False)<br>
df1.join(df2, lsuffix='_') - к одинаковым названиям прибавится суфикс '_'<br>
df = df1.set_index('key').join(df2.set_index('key')) - по одному индексу<br>
df1.join(df2.set_index('key'), on='key') - использовать столбец из df1<br><br>

<b>Merge</b><br>
Объеденить фрэймы; пересечение множеств (по умолчанию) inner; по левому (оно полностью останется и добавится из правого); правому и всё - outer. Объеденение по колонке с одинаковым названием (on="user_id") или задать (left_on, right_on)<br>
 
DataFrame.merge(self, right, how='inner', on=None, left_on=None, \
right_on=None, left_index=False, right_index=False, sort=False, \
suffixes=('_x', '_y'), copy=True, indicator=False, validate=None) <br>
df1.merge(df2, left_on='A', right_on='A1', how='inner')- из левого фрэйма 'A' \
<br><br>

<b>Concatenate</b><br>
pandas.concat(objs, axis=0, join='outer', join_axes=None, ignore_index=False, \
keys=None, levels=None, names=None, verify_integrity=False, sort=None, \
copy=True)<br>
pd.concat([df1, df2], sort=False, axis=0)<br>
df3 = pd.concat([df1, df2]) - сложились по столбцу<br>
df3 = pd.concat([df1, df2], axis=1) - получилось два столбца<br>

df1.update(df2)- у обоих df колонка с индексами и стобцы совпадают<br><br>

Среднее значение .mean()<br>
df_marks = pd.DataFrame(mydict)<br>
mean = df_marks.mean() ... среднее знач. по каждой колонке<br>
mean = df_marks.mean().mean() ... по всем колонкам<br>
mean = df_marks.mean(axis=1) ... по строкам<br>
print(pd.concat([df_marks['names'], mean], axis=1)) - столбецы 'name' + 'mean'<br>

extr = df['name_column'].str.extract(r"^(\d{4})", flag=0, expand=False)
   выбрали необходимое с помощью рег.выраж.<br><br>

for index, row in df.iterrows():<br>
    if row['date'] > 10:<br>
        print(row['date'])<br><br>
        
df = pd.DataFrame(np.random.rand(100000,2), columns=['a','b']) - тестовый df<br>
df.describe()<br>
fin=[] - сумма а и b<br>
for i,row in df.iterrows():<br>
    fin.append(row['a'] + row['b']) - медленно<br>
for i in range(len(df)):<br>
    fin.append(df['a'].loc[i]+df['b'].loc[i])<br>
for i in range(len(df)):<br>
    fin.append(df['a'].iloc[i]+df['b'].iloc[i])<br>
df.apply(lambda row: row['a']+row['b'], axis=1).to_list()<br>
for row in df.itertuples():<br>
    fin.append(row[1]+row[2])<br>
%timeit [a+b for a,b in zip(df['a'],df['b'])]<br>
(df['a'] + df['b']).to_list()<br>
%timeit (df['a'].values + df['b'].values).tolist() - быстро<br><br>

for col in df: - посчитать в % пустые значения в столбце<br>
    mis = np.mean(df[col].isnull())<br>
    print('{} - {}%'.format(col, round(mis*100)))<br>
med = df['name'].median() - заменить пустые знач на среднее<br>
df['name'] = df['name'].fillna(med)<br>

from pandas.plotting import scatter_matrix<br><br>

df.describe() - для колонок с числовыми данными count, mean, std, min, 25%, 50%, 75%, max по каждой колонке.<br>
df.describe(include='all') - для всех колонок.<br><br>

<b>Grouping and Aggregating</b><br>
contry_grp = df.groupby(['Country']) - DataFrameGroupBy object (по столбцу 'Contry').<br>
contry_grp.get_group('India') - df отсортирован по одной стране.<br>
contry_grp['SocialMedia'].value_counts().loc['India'] - посчитать сколько чел в Индии пользуются какими Media<br>

Поле по которому объеденяются фрэймы уходит в индекс;
column1_g = df.groupby('column1')['column2'].max() - для сводных таблиц; 1колонка - для которой формируем данные (или список колонок); 2колонка из которой берутся данные; и агрегативная ф-ция (count(), mean(), sum(), nunique(), min(), max())<br>
fst_pay = df_pay.groupby(['user', 'geo'])['pay_date'].min().reset_index() - группируем по двум столбцам и расчитываем дату первой оплаты, сбрасываем индекс.<br>
fst_pay = fst_pay.reset_index() можно отдельно<br><br>

Для грипировки по датам - колонка в формате datetime<br>
df['column'].groupby(df['date'].dt.month).nunique() - по месяцам(дням, годам)<br>

df['column'].agg(['count', 'mean', 'median']) - посчитать для колонки заданные ф-ции.<br>
df.agg({'column1': ['count', 'mean'], <br>
'column2': ['nunique']}) - посчитать для разных колонок<br><br>

Методы, которые принемают регулярные выражения: count(), replace(), contains(), extract(), findall(), match(), split(), rsplit()<br><br>

filt = df.date.str.contains('\w+', na=False) - возвращает булевые значения, пустые значения игнорировать.<br>
df.loc[filt] - df, соответствующие True<br>
df.loc[filt, 'km] = 300 - изменить значение в столбце km<br><br>

<b>.apply()</b><br>
user_info['type'] = user_info['temp'].apply(my_func) - к столбцу 'temp' применим ф-цию и сохраним р-т в новом столбце 'type'<br><br>


  </section>

  <section id="s13"><h3 align="center">NumPy</h3>
<b>import numpy as np</b><br>
y = np.arange(3,12,3) == range(3,12,3); list(y)<br>
x = np.array([a*a for a in y])<br>
np.random.random(10) - 10 значений от0 до 1<br>
  </section>

  <section id="s14"><h3>TeX</h3></section>
r"$x\ =\ \frac{\sqrt{144}}{2}\ \times\ (y\ +\ 12)$"
r"$x^2; h_2O$"<br><br>
  </section>

  <section id="s15">
<i>pip install pywin32</i>; <b>import win32api</b> - модуль для работы с windows<br><br>

<i>pip install py32printing</i>; <b>import win32print</b> - вывод на принтер через windows<br>
  </section>

  <section id="s16">
<b>import threading</b> - многопоточный метод<br><br>

def take_a_nap():
&nbsp;&nbsp;&nbsp;&nbsp;time.sleep(5)<br>
&nbsp;&nbsp;&nbsp;&nbsp;print('Wake up')<br><br>

thread_obj = threading.Thread(target=take_a_nap, args=[], kwargs={})<br>
thread_obj.start()<br><br>

В качестве аргументов метод принемает название ф-ции, аргументы ф-ции, ключевые слова в качестве словаря (например: {'sep':';'} для ф-ции print)<br><br>

for thred in all_threads:<br>
&nbsp;&nbsp;&nbsp;&nbsp;tread.join() - чтобы все потоки завршили работу перед завершением работы ф-ции.<br>
print('Done')
  </section>

  <section id="s17">
<i>pip install geocoder</i>; <b>import geocoder</b><br><br>

city = geocoder.arcgis('city_name')<br>
print(sity.json)<br>
print(sity.json['lat'], sity.json['lng'])<br>
  </section>
      </aside>
    </div>

      <footer><h3 id="s99">Ссылки:</h3>
<p><a href="https://docs.python.org/3/tutorial/introduction.html" target="_blank" rel="noopener" >The Python Tutorial</a> - Python 3.11.4 documentation</p>
<p><a href="http://automatetheboringstuff.com/2e/chapter1/" target="_blank" rel="noopener" >automatetheboringsruff</a> - AlSweigart</p>
<p><a href="https://pythex.org/" target="_blank" rel="noopener" >pythex</a> - regex</p>
      </footer>
  </div>  
</body>
</html>