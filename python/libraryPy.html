<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="../css/style1.css" />
    <title>libraryPy</title>
</head>
<body>
  <div class="cont">
    <nav class="menu">
      <ul class="menu_list">
        <li><a href="../index.html"><img src="../img/icon-home.png" alt="home"></a></li>
        <li>
          <span>Python</span>
          <ul class="sub_menu_list">
            <li><a href="./startPy.html">startPy</a></li>
            <li><a href="./libraryPy.html">libraryPy</a></li>
            <li><a href="./dir_and_file.html">Папки и файлы</a></li>
            <li><a href="./pictures.html">Картинки и графики</a></li>
            <li><a href="./data_analysis.html">Анализ данных</a></li>
            <li><a href="./web_scraping.html">Web scraping</a></li>
            <li><a href="./flask.html">Flask</a></li>
            <li><a href="./django.html">Django</a></li>
            <li>Искуственный интелект
              <ul>
                <li><a href="./ml.html">ML</a></li>
                <li><a href="./nlp.html">NLP</a></li>
                <li><a href="./gym.html">Gym</a></li>
              </ul>
          </ul>
        </li>
        <li>
          <span>Frontend</span>
          <ul class="sub_menu_list">
            <li><a href="../frontend/html.html">HTML</a></li>
            <li><a href="../frontend/css.html">CSS</a></li>
            <li><a href="../frontend/js.html">JavaScript</a></li>
            <li><a href="../frontend/jsDom.html">JavaScript DOM</a></li>
          </ul>
        </li>
        <li>
          <span>Books</span>
          <ul class="sub_menu_list">
            <li><a href="../books/english.html">Books in English</a></li>
            <li><a href="../books/math.html">Математика</a></li>
            <li><a href="../books/environment.html">Окружение</a></li>
            <li><a href="../books/digest.html">Справочники</a></li>
          </ul>
        </li>
      </ul>
    </nav>
    <div class="left_right">
      <aside class="left">
  <p>
    <a href="#s0">Библиотеки</a><br>
    <a href="#s1">random</a><br>
    <a href="#s1.1">math</a><br>
    <a href="#s1.2">string</a><br>
    <a href="#s2">sys</a><br>
    <a href="#s3">copy</a><br>
    <a href="#s4">pyperclip</a><br>
    <a href="#s6">shelve</a><br>
    <a href="#s7">pickle</a><br>
    <a href="#s8">pprint</a><br>
    <a href="#s9">pyinputplus</a><br>
    <a href="#s10">Время</a><br>
    <a href="#s11">Regex</a><br>
    <a href="#s12">Pandas</a><br>
    <a href="#s13">NumPy</a><br>
    <a href="#s14">TeX</a><br>
    <a href="#s15">pywin32</a><br>
    <a href="#s16">threading</a><br>
    <a href="#s17">geocoder</a><br>
    <a href="#s18">SQLite</a><br>
    <a href="#s19">BigQuery</a><br>
    <a href="#s20">subprpcess</a><br>
    <a href="#s21">colorama</a><br>
    <a href="#s22">translatepy</a></p>
      </aside>
    
      <aside class="right"><h1 align="center" id="s0">Library for Python.</h1>

  <section id="s1"> <b>import random</b><br>
<a href="https://docs.python.org/3/library/random.html#module-random" target="_blank" rel="noopener" >random</a> - Generate pseudo-random numbers<br><br>

<i>random.randint(a, b)</i> - случайное число от a до b, включая оба<br>
<i>random.choice([list])</i> - слуачайное значение из списка<br>
<i>random.choice(list(range(20)))</i> - случайное из 20<br>
<i>random.shuffle(list)</i> - перемешать список (на месте)<br>
<i>a = random.sample(list, 3)</i> - вернёт список из трёх рандомных значений<br>
<i>random.random()</i> - от 0 до 1<br>
<i>random.uniform(0,5)</i> - тоже с заданым диапазоном<br>
<i>random.seed(123)</i> - указать произвольное число и случайная последовательность будет повторяться.<br><br>

numbers = [random.randint(-10,10) for i in range(20)]
  </section>
  
  <section id="s1.1"><b>from math import *</b><br>
<a href="https://docs.python.org/3/library/math.html" target="_blank" rel="noopener" >Math</a> - Mathematical functions<br><br>

<i>gcd(*integers)</i> - Greatest common divisor (наибольший общий делитель)<br>
<i>lcm(*integers)</i>  Least common multiple (наименьшее общее кратное)<br>
<i>sqrt(x)</i> - Square root of x (квадратный корень)<br>
<i>isqrt(n)</i> - Integer square root (целочисленный квадратный корень)<br>
<i>isfinite(x)</i> - Check if x is neither an infinity nor a NaN<br>
<i>isnan(x)</i> - Check if x is a NaN (not a number)<br><br>

<i>degrees(x)</i> - Convert angle x from radians to degrees<br>
<i>radians(x)</i> - Convert angle x from degrees to radians<br>
<i>sin(x)</i> - Sine of x<br>
<i>pi</i> - π = 3.141592…<br>
<i>e</i> - e = 2.718281…<br>
<i>tau</i> - τ = 2π = 6.283185…<br>
<i>inf</i> - Positive infinity<br>
<i>nan</i> - “Not a number” (NaN)<br>
  </section>

  <section id="s1.2"><b>from string import *</b><br>
<a href="https://docs.python.org/3/library/string.html#module-string" target="_blank" rel="noopener" >String</a> - Common string operations<br><br>

<i>digits</i> - '0123456789'<br>
<i>hexdigits</i> - '0123456789abcdefABCDEF'<br>
<i>punctuation</i> - !"#$%&'()*+,-./:;&lt;=>?@[\]^_`{|}~.<br>
<i>ascii_letters</i> - 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ'<br>
<i>ascii_lowercase</i> - 'abcdefghijklmnopqrstuvwxyz'<br>
<i>ascii_uppercase</i> - 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'<br>
  </section>

  <section id="s2"> <b>import sys</b><br>

<i>sys.exit()</i> (Try, except; Ctrl+c - выход без выброса ошибки)<br>
  </section>

  <section id="s3"> <b>import copy</b><br>

копирование объектов<br>
<i>copy.copy(test)</i> - поверхносная копия<br>
<i>copy.deepcopy(test)</i> - глубокое копирование<br>
  </section>

  
  <section id="s4"> <i>pip install pyperclip;</i> <b>import pyperclip</b><br>

pyperclip.copy('Hello, world')<br>
pyperclip.paste()<br>
  </section>

  <section id="s6"> <b>import shelve</b><br>

сохранить как бинарные файлы; появятся три файла с расширениями <i>.bak, .dat, .dir</i>;<br>
open(path[, flag='c'[, protocol=None[, writeback=False]]])<br>
<i>c</i> (по умолчанию) - чтение и запись<br>
<i>r; w</i> - только для чтения или записи<br>
<i>n</i> - для записи создаётся или перезаписывается<br><br>

shelfFile = shelf.open('mydata') - принемает строку (не Path obj)<br>
cats = ['Zophie', 'Poork', 'Simon']<br>
shelfFile['cats'] = cats - сохранить как словарь по ключу<br>
shelfFile.close()<br><br>

shelfFile = shelf.open('mydata') <br>
shelfFile['cats'] .. ['Zophie', 'Poork', 'Simon']<br>
list(shelfFile.keys()) .. ['cats']<br>
list(shefFile.values()) .. [['Zophie', 'Poork', 'Simon']]<br>
shelfFile.close()<br><br>

with shelve.open('mydata') as shelve_f:<br>
&nbsp;&nbsp;&nbsp;&nbsp;if 'cats' in shelve_f:
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; print(cats = shelve_f['cats'])<br><br>

для перебора всех ключей используем цикл.<br>
метод keys() - верёт все ключи; метод values() - все значения; items() - набор кортежей<br>
pop(key, value) - удалит и вернёт ключ и значение по умолчанию (если ключ на найден)<br>
del shelve_f['key'] - удалить<br>
shelve_f.clear() - удалить всё<br>
  </section>

  <section id="s7"> <b>import pickle</b><br>

к режиму записи или чтения добавляем <i>'b'</i> ("wb", "rb")<br>
<i>dump(obj, file)</i> - записывавет объект в бинарный файл.<br>
<i>load(file)</i> - считывает данные из бинарного файла в объект.<br><br>

name = "Tom"; age = "19"<br>
with open("user.dat", "wb") as file:<br>
&nbsp;&nbsp;&nbsp;&nbsp; pickle.dump(name, file)<br>
&nbsp;&nbsp;&nbsp;&nbsp; pickle.dump(age, file)<br><br>

with open("user.dat", "rb") as file:<br>
&nbsp;&nbsp;&nbsp;&nbsp; name = pickle.load(file)<br>
&nbsp;&nbsp;&nbsp;&nbsp; age = pickle.load(file)<br>
&nbsp;&nbsp;&nbsp;&nbsp; print('Name: ', name, 'Age: ', age)<br><br>

users = [['Tom', 34, True], ['Alice', 23, False]]<br>
with open('users.dat', 'wb') as file:<br>
&nbsp;&nbsp;&nbsp;&nbsp; pickle.dump(users, file)<br><br>

with open('users', 'rb') as file:<br>
&nbsp;&nbsp;&nbsp;&nbsp; usersF = pickle.load(file)<br>
&nbsp;&nbsp;&nbsp;&nbsp; for user in usersF:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; print(f"Name {user[0]}, age: {user[1]}, married: {user[2]})<br>
    </section>

  <section id="s8"> <i>pip install pprint</i><br>

<b>import pprint</b><br><br>
<i>pprint.pprint</i> - печать списков<br>
<i>pprint.pformat</i> - вернёт текст в виде строки<br><br>

with open('myCats.py', 'w') as file:<br>
&nbsp;&nbsp;&nbsp;&nbsp;file.write('cats = ' + pprint.pformat(cats) + '\n' ) # записали в файл с расширением .py список словарей <br>
теперь можно вызвать import myCats; myCats.cats - вернёт список; к папке с файлом должен быть путь в 'переменных среды'<br>
  </section>

  <section id="s9"> <i>pip install pyinputplus</i><br>

<b>import pyinputplus as pyip</b><br><br>

print('Good' if pyip.inputInt() else None) - ввести целое число<br>
<i>pyip.inputInt('Enter your age: ', min=1)</i><br>
<i>pyip.inputStr()</i><br>
<i>inputNum(min=None, greaterThan=None, lessThan=None)</i> <br>
<i>inputChoice()</i><br>
<i>pyip.inputMenu(['one', 'two'][, numbered=True])</i> - выбрать из списка; опция - по индексу<br>
<i>inputDatetime()</i><br>
<i>inputYesNo()</i><br>
<i>inputBool()</i><br>
<i>inputEmail()</i><br>
<i>inputFilepath()</i><br>
<i>inputPassword()</i><br><br>

<i>help(pyip.parameters)</i> - посмотреть какие параметры доступны для всех вводов
  </section>

  <section id="s10"><h3 align="center">Время</h3>

UTC - Coordinated Universal Time<br>
EST, EDT - восточное, западное побережье Америки.<br>
Unix epoch - начало эпохи (1970, 1, 1, 12, 0, 0)<br><br>

<b>import time</b><br>
t = <i>time.time()</i> - без аргумента; привязана к системным часам; время в секундах с начала эпохи(1970-01-01 0:00:00 utc) Unix epoch timestamp<br><br>

start_time = time.time()<br>
print(f"Start {time.strftime('%H:%M:%S')}")<br>
<i>time.gmtime()</i> ..time.struct_time(tm_year=2023, tm_mon=10, tm_mday=6, tm_hour=13, tm_min=28, tm_sec=59, tm_wday=4, tm_yday=279, tm_isdst=0)<br>
<i>time.localtime()</i> ..time.struct_time(tm_year=2023, tm_mon=10, tm_mday=6, tm_hour=16, tm_min=29, tm_sec=13, tm_wday=4, tm_yday=279, tm_isdst=0)<br>
<i>time.ctime()</i> - Thu Aug 31 15:52:18 2023<br>
local = dt.datetime.fromtimestamp(t)<br>
zone = dt.timezone(dt.timedelta(seconds=abs(time.timezone))) ..10800сек (3часа)<br>
local = dt.datetime.fromtimestamp(t, zone) ..2023-10-06 17:00:48.587647+03:00<br>
<i>time.sleep(1)</i> - задержка 1с<br><br>

start_time = <i>time.monotonic()</i> - замеряем время от start_time.<br>
print(f"Прошло {time.monotonic() -  start_time}")<br><br>

time.strftime([format]) - текущее время в указаном формате.<br><br>

<b>import datetime as dt</b><br>
Классы: date, time, datetime<br>
<i>.date</i><br>
date(year, month, day)<br>
print(dt.date(2023,8,31)) .. 2023-08-31 (изоформат)<br>
today = dt.date.today() .. 2023-08-31<br>
print(f"{today.day}.{today.manth}.{today.year}") .. 31.8.2023<br><br>

today.replace(day=20) - изменит только в новой переменной.<br><br>

<i>.time</i><br>
time([hour][, min][, sec][, microsec]) (без параметров 0:0:0)<br>
print(dt.time(10,47,20)) .. 10:47:20<br><br>

<i>.datetime</i><br>
datetime(year, month, day [, hour][, min][, sec][, microsec])<br>
print(dt.datetime(2023,8,31)) .. 2023-08-31 00:00:00<br>
now = dt.datetime.now()<br> ..2023-08-31 10:58:03.968252<br>
now.date; now.month; now.year; now.hour, now.minute, now.microsecond, now.day_name<br>
ts = dt.datetime.timestamp(now) ..1696590800.965508<br>
dt.datetime.fromtimestamp(ts).date() .. 2023-10-06<br><br>

<i>strptime(str, format)</i> - распарсить строку; преобразовать в дату<br>
%d; %m; %y; %Y; %H; %M; %S - день; номер месяца; год (две цифры); год (4 цифры); час; минута; секунда<br>
deadline = dt.datetime.strptime("05-22-2017 12:30", "%m-%d-%Y %H:%M")<br>
print(deadline) .. 2017-05-22 12:30:00<br>
print(deadline.date()) ..2017-05-22<br><br>

<i>strftime(format)</i> - для объектов <i>date</i> и <i>time</i>; принимает один параметр - формат<br>
%a - Wed; %A - Wednesday; %b - Oct; %B - October<br>
%d - 01(день); %m - 05(месяц); %y - 23; %Y - 2023<br>
%H - 13(часов); %I - 01(час); %M; %S; %f - микросекунда<br>
%p - AM/PM; %c - дата и время местный формат<br>
%x; %X - дата; время - местный формат<br>
print(now.strftime("%d %b (%A)")) .. 31 Aug (Thursday)<br><br>

sber = pd.read_excel(r"financial.ods", engine='odf', sheet_name='sber', parse_dates=['date'], date_format='%d.%m.%Y')<br>
sber.loc[len(sber), ['date', 'sber_total', 's_invest', 'gold_g', 'gold_s',
                     'silv_g', 'silv_s']] = [today.strftime("%d.%m.%Y"),
                     sber_total, s_invest, gold_g, gold_s, silv_g, silv_s]<br><br>

<i>import locale</i><br>
<i>locale.setlocale(locale.LC_ALL, "")</i> - для использования русских(местных) слов<br><br>

<i>dt.timedelta([days][, seconds][, microseconds][, milliseconds][, minutes][, hours][, weeks])</i> - класс;<br>
now + dt.timedelta(days=100) .. плюс сто дней от now<br><br>

three_hours = dt.timedelta(hours=3, minutes=25) .. 3:25:00<br>
two_days = dt.timedelta(2, 25) .. 2 days, 0:00:25<br>
delta = three_hours + two_days .. 2 days, 3:25:25<br><br>

методы: <i>days, seconds, microseconds, total_seconds()</i><br>
delta.seconds; delta.total_seconds()<br><br>

if now > deadline:<br>
&nbsp;&nbsp;&nbsp;&nbsp;print("Time is over")<br>
elif now.day == deadline.day and now.month == deadline.month:<br>
&nbsp;&nbsp;&nbsp;&nbsp;print("today")<br>
else:
&nbsp;&nbsp;&nbsp;&nbsp;period = deadline - now<br>
&nbsp;&nbsp;&nbsp;&nbsp;print(f"осталось {period.days} дней")<br><br>

<b>import calendar</b><br>
today = dt.datetime.(2025,2,16)<br>
res = calendar.monthrange(today.year, today.month) ... (5, 28)<br><br>

<b>from threading import Thread</b><br>
# выполнение двух ниток потока<br>
def takeAnap():<br>
&nbsp;&nbsp;&nbsp;&nbsp;time.sleep(5)<br>
&nbsp;&nbsp;&nbsp;&nbsp;print('Wake up')<br><br>

threadObj = Thread(target=takeAnap)<br>
threadObj.start()<br>
print('The end')<br>
  </section>

  <section id="s11"><h3 align="center">Regex</h3>

<p><a href="https://habr.com/ru/articles/349860/" target="_blank" rel="noopener" >ShashkovS</a> - регулярные выражения<br>
<a href="https://proproprogs.ru/modules/literaly-i-simvolnyy-klass" target="_blank" rel="noopener" >proproprogs</a> - регулярные выражения<br>
<a href="https://docs.python.org/3/library/re.html" target="_blank" rel="noopener" >The Python Tutorial</a> - Python 3.11.4 documentation<br>
<a href=" https://www.regular-expressions.info/" target="_blank" rel="noopener" >regular-expressions</a> - подробный материал<br>
<a href="https://regex101.com/" target="_blank" rel="noopener" >regex101</a> - тренеровка</p>
<b>import re</b> - Regular expressions (regexes)<br><br>

Специальные символы: \ . $ ? + * {} [] () | - надо экранировать (\) <br>
Символьные классы [а-яА-ЯёЁ0-9], в них спец символы не работают (кроме '\')<br><br>
<table>
  <tr><td><b>.</b></td><td>любой символ; кроме \n; с флагом re.DOTALL - весь текст (wildcard)</td></tr>
  <tr><td><b>\d</b></td><td>любая цифра [0-9]</td></tr>
  <tr><td><b>\D</b></td><td>любой не цифровой символ [^0-9]</td></tr>
  <tr><td><b>\s</b></td><td>любой пробельный символ [\t\n\r\f\v]</td></tr>
  <tr><td><b>\S</b></td><td>любой непробельный символ</td></tr>
  <tr><td><b>\w</b></td><td>буквы и цифры, знак подчёрк [a-zA-Z0-9] (\w+ выберет слова)</td></tr>
  <tr><td><b>\W</b></td><td>не буквы и цифры [^а-яА-Я0-9Ёё]</td></tr>
  <tr><td>  </td></tr>
  <tr><td><b>|</b></td><td>или</td></tr>
  <tr><td><b>\b</b></td><td>граница слова</td></tr>
  <tr><td><b>^</b></td><td>отрицание для символьного класса или начало строки</td></tr>
  <tr><td><b>$</b></td><td>конец строки</td></tr>
  <tr><td><b>\A</b></td><td>начало текста</td></tr>
  <tr><td><b>\B</b></td><td>отсутствие границы слова</td></tr>
  <tr><td><b>\Z</b></td><td>конец текста</td></tr>
  <tr><td><b>(?:exp)</b></td><td>не сохраняющие скобки</td></tr>
  <tr><td><b>(?=exp)</b></td><td>проверка на совпадение</td></tr>
  <tr><td><b>(?!exp)</b></td><td> проверка на несовпадение</td></tr>
  <tr><td><b>(?&lt;=exp)</b></td><td>проверка на совпадение ретроспективная</td></tr>
  <tr><td><b>(?&lt;!exp)</b></td><td> проверка на несовпадение ретроспективная</td></tr>
</table><br>

<i>match = re.findall(r"^&lt;script.*?>([\w\W]+)(?=&lt;/script>)", re.M)</i> - совпадение все знаки до проверки на совпадение (всё между тегами; если использовать .* - не попадёт \n)<br>
<i>(?&lt;=&lt;script>)</i> - захватит и закрывающий тег<br>
<i>match = re.findall(r"([-\w]+)[ \t]*=[ \t]*[\" ']([^\" ']+)(?&lt;![ \t])", text, re.M)</i> - пары ключ, значение; ключ - символы, дефис; пробел или табуляция; равно; пробел или табуляция; ковычки; содержимое значения(до не кавычки); ретроспективная проверка на наличие пробела или табуляции (не вкл)<br><br>

<i>Квантификаторы</i><br>
{m} - повторений; {mix,max}; {min,}; {,max}<br>
по умолчанию - жадные(мажорные, greedy)<br>
со знаком '?' - нежадные(минорные, non-greedy) {2,5}? <br>
<b>?</b> - {0,1} re.findall(r"стеклянн?ый")<br>
<b>*</b> - {0,}<br>
<b>+</b> - {1,}<br><br>

text = "author=Pushkin; title=Onegin; price=200"<br>
match = re.findall(r"\w+\s*=\s*[^;]+", text) - вывести список из 'ключ=значение' (все знаки пока не встретится ';')<br><br>

text = "&lt;p>Picture &lt;img alt='photo' src='bj.jpg'>in text&lt;/p>"<br>
match = re.findall(r"&lt;img.*?>", text) - вывести содержание тега img (нежадный поиск до первой угловой скобки)<br>
match = rt.findall(r"&lt;img\s*=\s*[^>]*?src\s*=\s*[^>]+>", text) - содержимое тега img, все знаки кроме '>' нежадный поиск до 'src', = и все знаки не '>' до угловой скобки<br><br>

text = "lat=5, lon=7, a=3"<br>
match = re.findall(r"(?:lat|lon)\s*=\s*\d+", text) - используем не сохраняющую скобку и '|' для вывода списка из ключ=значение только для lat and lon<br>
если использовать сохраняющую скобку вывод будет - ['lat', 'lon']<br>
если ещё и всё выражение взять в скобки - [('lat=5', 'lat'), ('lon=7', 'lon')]<br>
если сохр скобки для (lat|lon) и (\d+) - [('lat', '5'), ('lon', '7')]<br><br>

Сохраняющие скобки (при search, fullmatch and finditer) не изменяют вывод, но можно получить инфо по каждой группе (если не используется квантификатор; тогда только для последнего соответсвия); match.start(), match.end() <br><br>

Нумерация в группах: pattern = r"((\d)(\d))((\d)(\d))"<br>
0 - весь шаблон; 1 - первые две цифры; 2 - первая цифра; 3 - вторая; 4 - вторые две цифры; 5 - третья цифра; 6 - четвёртая; \1\2..<br><br>

можно дать имя сохр скобке (в угловых скобках) - (?P&lt;name>) и обращатся к ней (?P=name)<br>
Для search можно получить коллекцию именованных групп.<br>
<i>v = match.groupdict(); v['name']</i><br><br>

<b>search</b><br>
<i>re.search(pattern, string, flags)</i> - находит первое совпадение или группы<br>
match = re.search(r"\s*([А-Яа-яЁё]+)(\d+)\s*", r"--Опять45--")<br>
print(match[0], <i>match.start</i>(0), <i>match.end</i>(0)) - весь шаблон<br>
print(match[1], match.start(1), match.end(1)) - первая группа<br>
print(match.group(0,1,2,3)) - кортеж из групп 0 - всё совпадение; 1 - первая группа..<br>
<i>match.span(1)</i> - start, end первой группы<br>
<i>match.groups()</i> - кортеж из всех групп<br>
<i>match.lastindex</i> - индекс последней группы (кол-во групп)<br>
<i>match.groupdict()</i> - если группы именованые получим словарь название_группы: значение<br>
<i>match.expand(r"\g&lt;название_группы>:\2")</i> - вывод значения по названию группы или по номеру<br>
<i>match.re</i> - компелированный шаблон<br>
<i>match.string</i> - анализируемая строка<br><br>

<b>re.finditer()</b> - то же, что и search, только используется в цикле для нахождения всех совпадений.<br><br>

<b>re.findall()</b> - список совпадений или только кортежи из сохраняющих групп <br><br>

<b>re.match()</b> - совпадение от начала строки<br><br>

<b>re.fullmatch</b>(pattern, string) - проверить полное совпадение под шаблон <br><br>

<b>re.split</b>(pattern, string, maxsplit=0) - разделение по подстрокам, подходящим под шаблон; выбрать разделитель<br>
print(re.split(r"\W+", "Где скажите мне, мои очки?"))
... ["Где", "скажите", "мне", "мои", "очки", " "] - список без пробелов<br><br>

[i.lower() for i in re.split(r"\W+", text) if i] # слова в нижнем регистре без пробела в конце<br><br>

<b>re.sub</b>(pattern, repl, string, count=0, flags) - (substitution) заменить все непересекающиесся шаблоны на repl (строка или ф-ция)<br>
result2 = re.sub(r"old", r"new", txt) - заменить<br><br>

<b>re.subn</b> - тоже; плюс кол-во замен<br><br>

pattern = <i>re.compile</i>(r'\d{3}') - шаблон передаём в  re.compile() и сохраняем в regex object<br>
result = <i>pattern.search</i>(txt).group()<br>
print(result[0] if result else 'NO')<br><br>

text = "Moscow Saint-Petersburg Novgorod"<br>
result2 = re.sub(r"\s*([\w-]+)\s*", r"&lt;option>\1&lt;/option>\n", text)<br>
print(result2)<br><br>

count = 0<br>
def replFind(m): # аргумент - объект Match<br>
&nbsp;&nbsp;&nbsp;&nbsp; global count<br>
&nbsp;&nbsp;&nbsp;&nbsp; count += 1<br>
&nbsp;&nbsp;&nbsp;&nbsp; return f"&lt;option value='{count}'>{m.group(1)}&lt;/option>\n"<br>
result2 = re.sub(r"\s*([\w-]+)\s*", replFind, text)<br>
.. &lt;option value='1'>Moscow&lt;option>...<br><br>

Использование групп при замене:<br>
Можно ссылаться на соответсвующую группу при помоощи \1, \2, ...(если групп больше 9, то \g<12>)<br>
print(re.sub(r"(\d\d)/(\d\d)/(\d{4})", r"\2.\1.\3", "03/25/2023")) - дата по амер; вернёт в нормальном порядке через точку<br><br>

 <b>flags:</b><br>
 <i>re.A (re.ASCII)</i> только латинские буквы, цифры и символ подчёркивания<br>
 <i>re.I (re.IGNORCASE)</i> - без учёта реистра символов.(case-insensitive)<br>
 <i>re.M (re.MULTILINE)</i> - влияет на проверки ^, $(с начала строки)<br>
 <i>re.S (re.DOTALL)</i> - ищет по всему тексту<br>
 <i>re.X (re.VERBOSE)</i> - позволяет вкл коментарии. <br>
 <i>re.DEBUG</i> - режим отладки.<br><br>

 Флаги можно комбинировать с помощью пайп (pipe) "|"<br>
 match = re.findall(r"(?aimsx)python", text) - включить флаги в шаблон
  </section>

  <section id="s12"><h3 align="center">Pandas</h3>

<p><a href="https://pandas.pydata.org/docs/reference/index.html" target="_blank" rel="noopener" >pandas</a><br>
<a href="https://yandex.ru/video/preview/15221246385215675350" target="_blank" rel="noopener" >Анализ Данных на Python и Pandas</a></p>

<i>pip install pandas</i><br>
<b>import pandas as pd</b><br><br>

<b>Series</b><br>
mySeries = pd.Series(my_dict) - ключи будут индексами; можно обращатся по ключу (mySeries.Name)<br>
или mySeries.iloc[] - по цифровому индексу; в качестве индекса может быть срез или условие<br>
..type(mySeries) ..class 'pandas.core.series.Series'<br><br>

mySeries[mySeries > 100] - серия в которой  значения больше 100<br>
mySeries + 2 - ко всем значениям прибавить 2; так же другие операции<br>
sorted(mySeries) - список отсортированых значений (len, min, max, set, sum, product, mean, abs, head(), tail(), take([])) - могут использоватся как метод или аргумент<br>
.sort_values(inplace=False, ascending=False); после сортировки индексы будут не по порядку.<br>
.sort_index() - восстановить порядок индексов (также имена или даты)<br>
.index, .dype<br><br>

s = pd.Series(range(50)); s[3:40:3] - срез от 3 до 39 шаг 3(-3 обратный счёт)<br>
s.loc[[2,3]] - выбор двух строк; срез вкл оба знач; s.iloc[5:2:-1]<br><br>

df.dtypes; df.Name.dtype<br>
float   -           (float64)<br>
int     -             (int64)<br>
datetime-    (datetime64[ns])<br>
string  -            (object)<br><br>

<i>df = pd.DataFrame(data, columns=[list], index=[list])</i><br> 
..&lt;class 'pandas.core.frame.DataFrame'></class><br><br>

data - список списков, словарь, список словарей<br>
data = {'a':[list], 'b':[list]} ключи - назв.колонок, списки - значения(колонки)<br>
data = [['Alex', 10], ['Bob', 12], ['Clar', 13]]- список строк, две колонки(стр)<br>
data = [{dict1}, {dict2}] - каждый словарь - строка<br>
data = {'a':{'1': 'a1', '2': 'a2'}, 'b':{'1': 'b1', '2': 'b2'}} - словари со вложеными; a - назв.столбцов, '1'- индекс; 'a1' - значение<br>
df = pd.DataFrame([Series1, Series2]) - две строки в df<br><br>

один столбец представляется как Series; чтобы получить df надо применить к ней .reset_index() или подставить в конструктор pd.DataFrame(Series)<br><br>

<b>Прочитать, выгрузить в другой формат</b><br>
df = pd.read_csv(path, index_col='date', sep=';') - индексами сделать 'date'
   sep- разделитель, header=None, skiprow=[0,1,3], usecols=None, nrows = None - кол-во строк, encoding='1251', na_values = ['NA', 'Missing'] (заменить значения на пустые)<br>
col_names = [список новых заголовков]<br>
data = pd.read_csv(path, names=col_names, skiprows=[0]) - новые заголовки,
строку со старыми пропустить<br>
skiprows = [0,3,5] - пропустить указанные строки<br>
header= None, skiprows=[0] -  удалить заголовки<br><br>
d_parser = lambda x: pd.datetime.strptime(x, '%Y-%m-%d %I-%p')<br>
df = pd.read_csv(path, parse_dates=['date'], date_parser=d_parser) - 'date' - Dtype - datetime64[ns]
    (index_col='date', parse_dates=True); index_col=0 (первый столбец без имени станет индексами)<br>
df = pd.read_csv(path, usecols=[], nrows=100) - выбрать колонки и кол-во строк/вывода<br>
custom_datetime = lambda x: datetime.strptime(x, '%d%m%Y %H:%M:%S')<br>
df = pd.read_csv('тест2.csv', parse_dates=['date'], parse_dates=True,date_parser=custom_datetime)<br>
df.to_csv('path', index=False)<br><br>

df = pd.read_excel(path, engine='odf', sheet_name='вещи', index_col='Дата')<br>
df.to_excel(path) - сохранить в таблице (один лист)<br>
для записи нескольких листов: <br>
writer = pd.ExcelWriter('table.ods', engine='odf', date_format=None, datetime_format=None, mode='w'('a'), storage_options=None, if_sheet_exists=None, engine_kwargs=None)<br>
df1.to_excel(writer, sheet_name='name1'); writer.save()<br><br>

with pd.ExcelWriter("my_table.ods", engine='odf') as writer:<br><br>

df = pd.read_sql_query(query, db)<br><br>

df_list = pd.read_html(url) - возвращает список найденых фреймов<br>
df_list[0].info()<br><br>

df.describe() - статистики по столбцам<br>
pd.options.mode.chained_assignment = None - Чтобы временно отключить предупреждение <br><br>

Поменять в столбце "вид" название растений на цифры<br>
lablel_encode = {'вид': {'iris0': 0, 'iris1': 1, 'iris2': 2}}<br>
df1 = df.replace(label_encode)<br><br>

df['date'] = pd.to_datetime(df[date], format="%Y-%m-%d %I-%p", errors='ignore')<br>
df['date', 'start'] = df[['date', 'start']].apply(pd.to_datetime) - два столбца<br><br>

df.info() - кол-во строк(entries), индексы, название колонок, кол-во знач в них<br>
df.shape - кортеж (tupl) кол-во строк, кол-во колонок<br>
df.size - кол-во клеток в таблице<br>
df.T - transpose - меняет строки и столбцы местами<br>
df.dtypes - назв. колонок и тип данных в каждой<br>
df.values - список списков всех данных<br>
df.columns - список колонок<br>
df.index -  список индексов<br>
df.axes - список индексов и колонок<br>
df.head() - начало df<br>
df.tail() - конец df<br>
df.sample() - случайные строки<br><br>

df['reveneu'].nlargest(10) - 10 самых больших значений (Series).<br>
df.nlargest(10, 'revenue') - 10 строк (df).<br>
.nsmallest() - наименьшие.<br>

df.loc['name_str', 'name_column']<br>
df.loc[1] - первая строка Series<br>
df.loc[1:], df.loc[:5], df.loc[2:4], df.loc[[2,5], ['km', 'l']]<br>
df.loc[[5]] - строка по индексу DataFrame<br>
df.iloc[5], df.iloc[0,5] - по цифровому индексу [строка,колонка]<br>
df.loc[len(df)-1] - последняя строка Series<br>
df.loc[len(df)-1, ['data', 'note']] - посл. строка в двух колонках<br>
df.loc[:, 'name_column'] - весь сттолбец<br>
df.loc[:, ['name1', 'name2']] - два столбца<br>
df.loc[:, 'name1':'name2'] - несколько столбцов подряд<br>
df.iloc[[1,3]] - первая и третья строка<br><br>

df['name_columns'], df.name_columns - колонка Series<br>
df[2:4] - сокращённое две строки df<br><br>

<b>Индексы</b><br>
df.index.dtype - тип данных<br>
df.reset_index(inplace=True) - индексы стали первым столбцом<br>
df.reset_index(drop=True, inplace=True)- переустановить индексы<br>
df.set_index('month', inplace=True) - столбец 'month' стал индексами<br>
df = pd.read_csv(path, index_col='month') - прочитать csv 'month' - индексы<br>
df.to_csv(path, index_label='month') - сохран. в csv столбец индексов с именем<br>
df.svechi.dropna().index - список индексов соотв. не пустым знач. в 'svechi'<br>
df.svechi.dropna().index [-1] -  последний индекс в списке<br>
df.index[df.svechi == 206795]  - индекс значения 206795<br>
df.sort_index(axis=0, inplace=True)<br>
df.rename(index={'old': 'new'}, inplace=True)<br>
df.index = [список новых индексов]<br>
df.index.names = ['month'] - переименовали колонку с индексами<br>
df.rename_axis('manth', axis='rows') <br><br>

df = df.set_index('enrollee_id').reset_index(drop=True).rename_axis('enrollee_id').reset_index() -  установили индексы; переустановили [0,1..] (теперь колонка называется 'Index'); переименовали; вернули как колонку<br>
<i># Избавиться от мультииндекса.</i> (теперь он один через подчёркивание)<br>
t.columns = ['_'.join(col).strip() for col in t.columns.values]<br><br>

<b>Столбец</b><br>
df = pd.read_csv(path, names=[list], skiprows=[0])- поменяли заголовки,
     оригинальные пропустили<br>
df['name_column'] - столбец в Series (df.name_column)<br>
df[['name1', 'name2']] - несколько столбцов df<br>
df.assign(new_col=99) - вспомогательный столбец со знач 99<br>
df.astype({'name_column': 'int'}) - преобразовать тип данных в столбце<br>
df.name.dropna() - вызвать стобец 'name' без пустых значений<br>
subset =[] -  аргумент в котором указываются столбцы в которых искать<br>
df.rename(columns={'name1': 'new_name1'}, inplace=True) - переименовать<br>
df = df[['b', 'c', 'a', 'd']] - поменять порядок столбцов<br>
df.columns = ['name1', name2...nameN] - переименовать список столбцов<br>
df['new_name'] = [1,2,3] - новый столбец и значения соответсвуют кол. строк<br>
    одно значение  - повторится во всех строках<br>
df.insert(2, 'Team', [list values]) - (индекс колонки перед которой вставляем,
    название, данные)<br><br>

df.date = pd.DatetimeIndex(df.date) - столбец date - формат времени<br>
df.age = df['age'].astype(float) - пустые знач только в float<br>
df = df.astype({'price': 'int', 'usdprice': 'float'})<br>
del df['name_column']                                   - удалить столбец<br>
df.drop(['name_column'], axsis=1, inplace=True)         - удалить столбец<br>
df = df.drop(['name1_column', 'name2_column'], axis=1)  - удалить столбецы<br>
df.pop('name_column')                                   - удалить столбец<br>
df = df[['column1', 'column3']] - выбрать нужные столбцы<br><br>

df[pd.isnull(df.country)] - df в котором название стран пропущено<br>
df.country.fillna('Unknown') - заменить пропущенные значения на 'Unknown'<br>
.fillna(dict(name=value))<br>
df.country.mode()[0] - самое частое<br>
df.name.replace('Bob', 'Dan') - заменить имя в колонке<br><br>

df.groupby('Cluster').mean() - сгрупировали по столбцу Cluster и посчитали
  среднее значение<br>
df.loc[df.Name == 'Bob'] - все строки с именем Bob<br>
df.loc[df.Name == 'Bob', 'Name'] = 'Kat' - в столбце Name заменили имя<br>
<i>and</i> - <b>&</b>; <i>or</i> - <b>|</b>; <i>not</i> - <b>~</b><br><br>

room3 = df.room3<br>
room3.loc[room3 > 100] - в столбце room3 значения больше 100<br><br>

result_df.date = result_df.date.apply(lambda i: i[:10]) - сохранить только 10 знаков<br><br>

df['income_num'] = (df['income'] != '&lt;=50K').astype(int) - изменить значения на 0 и 1<br><br>

<b>Строки</b><br>
df.loc['May'] = [list] - изменить/создать строку с индексом 'May'<br>
df.loc[len(df)]; df.iloc[-1] - последняя строка<br>
df.loc['name']  - строка с именем<br>
df.append({'A': 'bar', 'B': 4}, ignor_index=True)<br>
df.append(pd.Series(['bar', 4], index=['A', 'B'], ignor_index=True))<br>
df = df.drop(1, axis=0) - удалить первую строку<br>
df.drop('name_index',axis=0, inplace=True) - удалить строку<br>
df.drop(df.tail(1).index, inplace=True) - удалить последнюю строку<br><br>

df1 = df[:-n] - удалить n строк<br><br>

line = pd.DataFrame({dict}, index=[3]) - вставить строку<br>
df2 = concat([df.iloc[:2], line, df.liloc[3:]].reset_index(drop=True))<br>

line = pd.DataFrame({dict}, index=[2,5])<br>
df2 = df.append(line, ignor_index=True)<br>
df2 = df2.sort_index().reset_index(drop=True)<br><br>

третий способ вставить строку<br><br>

<b>Сортировка</b><br>
df.sort_values(by='name_column', or list of columns, ascending=False, inplace=False, <br>
kind='quicksort', no_position='last', ignore_index=False, key=None)
ascending - по возрастанию<br>
kind= [quicksort, mergesort, heapsort]<br>
key = любая ф-ция<br>
df.sort_values(by=['date', 'start'], ascending=[True, False], inplace=True)<br><br>

abr_df.sort_values(by=['type', 'vol'], inplace=True, key=lambda col: col.str.lower())<br><br>

df = pd.concat([df1, dff2], ignore_index=True) - индексы(цифры) переустановить<br>
 
set_option<br>
pd.set_option('display.max_rows', None)<br>
pd.set_option('display.max_columns', None)<br>
pd.set_option('display.max_colwidth', None)<br><br>

<b>Фильтрация</b><br>
query:<br>
df.query("city == 'Pts' and gender == 'male'") - фильтр из df колонка 'city' и колонка 'gender'<br><br>

pandas notations:<br>
df[df.price > 1000 ] - df в котором  значения соответствующей колонки >1000<br>
df[(df.price > 100) & (df.price &lt; 500)] - '~', '|', '&'<br>
df[df.prodact.str.contains('LG', regex=True, na=False)] - метод 'str' применяется к Серии, разные аргументы (startwith..); может использовать regex; не учитывать пустые значения<br>
df = df[['name1', 'name2']][filter].copy() - две колонки по условию; сохранить копию<br> 
df[filter].loc[:, ['name1', 'name2']] - тоже<br><br>

df[~df.column.isna()]  # все не-пропущенные значения<br><br>

<b>Время</b><br>
<i>NaT</i> - not a time; эквивалент NaN<br>
timestamp = pd.Timestamp("2023-03-25 15:30:00") - Timestamp('2023-03-25 15:30:00')<br>
timestamp.year; ().month; .day; .hour; .minute;  .weekday()
df.reset_index(inplace=True) - индексы в первую колонку<br>
df['date'] = pd.to_datetime(df['date'], dayfirst=True)<br>
df['date'] = pd.to_datetime(df['date'], format="%Y %B %d")<br>
df.sort_values(by='date', inplace=True)<br>
df.to_csv(path, index=False) - сохранить без столбца индексов<br>
df.set_index('date', inplace=True) - 'date' индексы<br>
df.date['2021-01':'2021-02-25'] - срез по индексам (всё включено)<br>
avto.dayOfWeek = avto.date.dt.day_name() - новый столбец с днями недели<br>
.min(), .max()<br> 
avto.loc[avto.date>='2023'] - фрейм за 2023 год<br>
filt = (avto.date >= '2020') & (avto.date &lt; '2021')<br>
filt - (avto.date >= pd.to_datetime('2020-01-01'))<br>
highs = avto['revenue'].resample('m').max() - выборка по месяцам (список обозначений в документации)<br>
highs['2021-01-01'] - выбор по индексу.<br><br>

атрибут 'dt'<br>
.dt.year, .dt.month, .dt.day, .dt.dayofweek (0 - понедельник)

<b>Диапазон дат</b><br>
pd.date_range(start=datetime(year=2020, month=1, day=1), <br>
periods=30,
freq='D')   ...   DatetimeIndex(['2020-01-01', '2020-01-02', ... '2020-01-30'])<br>
date = pd.date_range('1/1/2022', periods=5, freq='H')<br>
DatetimeIndex(['2022-01-01 00:00:00', ...  '2022-01-01 05:00:00'])<br>

df = pd.concat([df1, df2], ignor_index=True) - восстановить порядок индексов<br><br>

<b>update</b>:<br>
обновит только существующие колонки или строки (лишнее игнорирует)<br>
df = pd.DataFrame(dict(A=[1,2,3], B=[4, 5, 6], C=[7, 8, 9]))<br>
new_column = pd.Series([40, 50], name='B', index=[0, 1])<br>
df.update(new_column) ... обновит стобец "В" два значения<br><br>

new_df = pd.DataFrame(dict(B=[40, 50]), index=[0,1])<br>
new_df = pd.DataFrame(dict(B=[40, 50, np.nan]))<br>
df.update(new_df) ... обновит стобец "В" два значения<br><br>

<b>Join</b><br>
DataFrame.join(self, other, on=None, how='left', \
                lsuffix='', rsuffix='', sort=False)<br>
df1.join(df2, lsuffix='_') - к одинаковым названиям прибавится суфикс '_'<br>
df = df1.set_index('key').join(df2.set_index('key')) - по одному индексу<br>
df1.join(df2.set_index('key'), on='key') - использовать столбец из df1<br><br>

<b>Merge</b><br>
Объеденить фрэймы; пересечение множеств (по умолчанию) inner; по левому (оно полностью останется и добавится из правого); правому и всё - outer. Объеденение по колонке с одинаковым названием (on="user_id") или задать (left_on, right_on)<br><br>
 
DataFrame.merge(self, right, how='inner', on=None, left_on=None, \
right_on=None, left_index=False, right_index=False, sort=False, \
suffixes=('_x', '_y'), copy=True, indicator=False, validate=None) <br>
df1.merge(df2, left_on='A', right_on='A1', how='inner')- из левого фрэйма 'A' \
<br><br>

<b>Concatenate</b> - используем, когда фрэймы имеют одинаковые поля<br>
pandas.concat(objs, axis=0, join='outer', join_axes=None, ignore_index=False, \
keys=None, levels=None, names=None, verify_integrity=False, sort=None, \
copy=True)<br>
pd.concat([df1, df2], sort=False, axis=0)<br>
df3 = pd.concat([df1, df2]) - сложились по столбцу<br>
df3 = pd.concat([df1, df2], axis=1) - получилось два столбца<br>

<i>num = 1</i><br>
<i>for i in range(len(df)):</i> - пройтись по длине всго df (df.shape[0])<br>
&nbsp;&nbsp;&nbsp;&nbsp;<i>tmp = df.iloc[i:i+1000]</i> - df по 1000 строк<br>
&nbsp;&nbsp;&nbsp;&nbsp;<i>tmp.to_csv(f'somefiles/part_{num}.csv", index=False)</i> - сохранить в csv с номерами<br>
<i>num += 1</i><br>
<i>df_all = pd.DataFrame()</i> - собрать в этот df однотипные df из папки<br>
<i>for f in os.listdir('somefiles/'):</i><br>
&nbsp;&nbsp;&nbsp;&nbsp;print(f) - все файлы из папки<br>
&nbsp;&nbsp;&nbsp;&nbsp;<i>tmp = pd.read_csv('somefiles/'+f)</i><br>
&nbsp;&nbsp;&nbsp;&nbsp;<i>df_all = pd.concat([df_all, tmp])</i><br><br>

df1.update(df2)- у обоих df колонка с индексами и стобцы совпадают<br><br>

Среднее значение .mean()<br>
df_marks = pd.DataFrame(mydict)<br>
mean = df_marks.mean() ... среднее знач. по каждой колонке<br>
mean = df_marks.mean().mean() ... по всем колонкам<br>
mean = df_marks.mean(axis=1) ... по строкам<br>
print(pd.concat([df_marks['names'], mean], axis=1)) - столбецы 'name' + 'mean'<br><br>

масимальное вычисленное значение соответсвует названию:<br>
bargain_idx = (reviews.points / reviews.price).idxmax()<br>
bargain_wine = reviews.loc[bargain_idx, 'title']<br><br>

reviews.loc[reviews.country.isin(['Itali', 'France'])] - выбрать строки в которых страна Италия или Франция.<br>
reviews.loc[reviews.price.notnull()] - фрейм в котором price != 0<br><br>

ф-ция map принемает каждое значение Series  и возвращает новое Series<br>
review_points_mean = reviews.points.mean()<br>
reviews.points.map(lambda p: p - review_points_mean)<br><br>

то же с apply<br>
def remean_points(row):<br>
&nbsp;&nbsp;&nbsp;&nbsp;row.points = row.points - review_points_mean<br>
&nbsp;&nbsp;&nbsp;&nbsp;return row<br>

reviews.apply(remean_points, axis='columns')<br><br>

extr = df['name_column'].str.extract(r"^(\d{4})", flag=0, expand=False)
   выбрали необходимое с помощью рег.выраж.<br><br>

for index, row in df.iterrows():<br>
    if row['date'] > 10:<br>
        print(row['date'])<br><br>
        
df = pd.DataFrame(np.random.rand(100000,2), columns=['a','b']) - тестовый df<br>
df.describe()<br>
fin=[] - сумма а и b<br>
for i,row in df.iterrows():<br>
&nbsp;&nbsp;&nbsp;&nbsp;fin.append(row['a'] + row['b']) - медленно<br>
for i in range(len(df)):<br>
&nbsp;&nbsp;&nbsp;&nbsp;fin.append(df['a'].loc[i]+df['b'].loc[i])<br>
for i in range(len(df)):<br>
&nbsp;&nbsp;&nbsp;&nbsp;fin.append(df['a'].iloc[i]+df['b'].iloc[i])<br>
df.apply(lambda row: row['a']+row['b'], axis=1).to_list()<br>
for row in df.itertuples():<br>
&nbsp;&nbsp;&nbsp;&nbsp;fin.append(row[1]+row[2])<br>
%timeit [a+b for a,b in zip(df['a'],df['b'])]<br>
(df['a'] + df['b']).to_list()<br>
%timeit (df['a'].values + df['b'].values).tolist() - быстро<br><br>

<b>Grouping and Aggregating</b><br>
reviews.groupby('points').points.count() - сгрупировать по 'points' и посчитать сколько строк с каждым значением 'points'<br>
reviews.groupby('points').price.min() - минимальная цена на кажое значение 'points'<br>
contry_grp = df.groupby(['Country'], dropna=False) - DataFrameGroupBy object (по столбцу 'Contry'), учитываем пропущенные значения<br>
contry_grp.get_group('India') - df отсортирован по одной стране.<br>
contry_grp['SocialMedia'].value_counts().loc['India'] - посчитать сколько чел в Индии пользуются какими Media<br>

Поле по которому объеденяются фрэймы уходит в индекс;
column1_g = df.groupby('column1')['column2'].max() - для сводных таблиц; 1колонка - для которой формируем данные (или список колонок); 2колонка из которой берутся данные; и агрегативная ф-ция (count(), mean(), sum(), nunique(), min(), max())<br>
fst_pay = df_pay.groupby(['user', 'geo'])['pay_date'].min().reset_index() - группируем по двум столбцам и расчитываем дату первой оплаты, сбрасываем индекс.(.sort_index(ascending=True) - сортировать индекс)<br>
fst_pay = fst_pay.reset_index() можно отдельно<br><br>

# кол-во строк в каждой группе<br>
reviews_written = reviews.groupby('taster_twitter_handle').size()<br><br>

df.groupby(['education', 'educational-num']).size().sort_index(level=1) - двухуровневый индекс; сортируем по второму<br><br>

Для грипировки по датам - колонка в формате datetime<br>
df['column'].groupby(df['date'].dt.month).nunique() - по месяцам(дням, годам)<br>

df['column'].agg(['count', 'mean', 'median']) - посчитать для колонки заданные ф-ции.<br>
df.agg({'column1': ['count', 'mean'], <br>
'column2': ['nunique']}) - посчитать для разных колонок<br><br>

Методы, которые принемают регулярные выражения: count(), replace(), contains(), extract(), findall(), match(), split(), rsplit()<br><br>

метод <i>str</i><br>
df[['expense', 'notes_a']][df.notes_a.str.contains(r'(?i)\bм\b', na=False)]<br>
filt = df.date.str.contains(r'(?i)\w+', na=False).copy() - возвращает булевые значения, пустые значения игнорировать, сохраняем копию из df.<br>
df.loc[filt] - df, соответствующие True<br>
df.loc[filt, 'km'] = 300 - изменить значение в столбце km<br><br>

<b>.apply()</b><br>
user_info['type'] = user_info['temp'].apply(my_func) - к столбцу 'temp' применим ф-цию и сохраним р-т в новом столбце 'type'; так же lambda x: x*2<br><br>

<i>def get_timestamp(y, m, d):</i><br>
&nbsp;&nbsp;&nbsp;&nbsp;<i>return dt.datetime.timestamp(dt.datetime(y, m, d))</i><br><br>

<i>def get_date(tmstmp):</i><br>
&nbsp;&nbsp;&nbsp;&nbsp;<i>return dt.datetime.fromtimestamp(tmstmp).date()</i><br><br>

<b>Анализ данных</b><br>
<i>Пропуски</i><br>
df[df.Gender.isna()] (df[pd.isna(df.Gender)]) - df в котором пропущены знач в колонке 'Gender'<br>
df.room.isna().sum() - кол-во пустых строк<br>
df.isna().mean().sort_values(ascending=False) - посмотреть пропущенные  знач по каждому столбцу сортированые по убыванию (доля пропущенных значений к общему кол-ву)<br><br>

df.isin(["?"]).sum() - посчитать в разных столбцах сколько '?'<br><br>

Для непрерывных значений смотрим гистограмму (х - разные значения; у - кол-во значений)<br>
df.something.hist()<br><br>
или<br>
df.describe() - для колонок с числовыми данными count, mean, std, min, 25%, 50%, 75%, max по каждой колонке.<br>
df.describe(include='all') - для всех колонок.<br><br>

df.sort_values([name1, name2], ascending=[False, True], inplace=False, key=lambda x: x.str.lower())<br>
df.names.unique() - уникальные значения в столбце names<br>
df.names.nunique() - кол-во уникальных значений<br><br>

.fillna(0, inplace=True) - заменить пустые значения на указаное<br>
df.fillna(method='pad')
df.name = df['name'].fillna('unknown') - заменить значения в столбце<br>
.dropna(self, axis=0, how='any'(all - если все значения пропущены), thresh=None, subset=None(исключение для столбцов), inplace=False) - пропустить все пустые <br>
.duplicated()<br>
.drop_duplicates(inplace=True)<br>
.replace(name1, name2); df.replace(to_replace=np.nan, value=99)<br>
df['room'].min(); df['room'].max()<br><br>

tenis.name = tenis.name.replace('Roger', 'Robert')<br>

Для категориальных значений<br>
df.names.value_counts() - кол-во разных значений; аргумент [normalize=True] - в долях от общего кол-ва.<br><br>

df.gender.value_counts(dropna=False) - (observed=False) посмотреть категориальную колонку, учитывать пропущенные знач.<br><br>

df.gender.apply(lambda x: 'no_info' if (x == 'Other' or pd.isna(x)) else x).value_counts(dropna=False) - заменить в колонке пропуски и other на 'no_info'<br><br>

.isna(), isnull(), notna(), .notnull() - возвращает булевое знач<br>
.sum() - суммирует<br><br>

label_encode = {'column_name': {'iris0': 0, 'iris1': 1}}<br>
df1 = df.replace(label_encode)<br>
df[name].count() - посчитать количество элементов<br>
df[name].value_counts() - посчитать кол-во каждого элемента<br>
x = iris.iloc[:,:-1].values - список списков - значения 4 из 5 столбцов<br><br>

<i># Разбить непрерывную переменную на 5 групп</i> (также работает гистограмма)<br>
df['age_cut'] = pd.cut(df.Age, 5)<br>
# или нарезать группы в ручную<br>
df['age_cut'] = pd.cut(df.Age, [-float('inf'),0,18,30,float('inf')])<br>
df.groupby('age_cut', observed=False)[].agg(['count', 'sum', 'mean']).reset_index() - разбили колонку 'Age' на 5 частей и сгруппировали данные по каждой<br><br>

# Что бы разбить по кол-ву строк (не значение переменной) используем qcut()<br>
df['city_development_q'] = pd.qcut(df['city_development'], 5, duplicates='drop') - дополнительный параметр, если много одинаковых данных<br>
df.groupby('city_development_q', dropna=False)['target'].agg(['count', 'mean'])<br><br>

Что бы объеденить какие-то группы<br>
Не используем циклы для pandas. Используем apply<br>
def education_gr(x):<br>
&nbsp;&nbsp;&nbsp;&nbsp;if x in ['high school', 'primary school']:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return 'school'<br>
&nbsp;&nbsp;&nbsp;&nbsp;if x in ['masters', 'phd']:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return 'mast and phd'<br>
&nbsp;&nbsp;&nbsp;return x # всё, что не попало в группы<br><br>

df['new_exucation'] = df['education_lv'].apply(educatin_gr) - создали новую колонку с новыми группами<br><br>

или используем replace<br>
df['education_lv'].replace('prymary school', 'school') - для всех необходимых замен<br><br>

другой способ - с помощью 'map'<br>
d = dict(primary='school', high='school')<br>
df['education_lv'].map(d)<br><br>

n_trop = reviews.description.map(lambda desc: "tropical" in desc).sum() - в колонке 'description' посчитали количество слов 'tropical'<br><br>

<i>Создать Series по условию из колонок 'country' and ' 'points'</i><br>
def stars(row):<br>
&nbsp;&nbsp;&nbsp;&nbsp;if row.country == 'Canada':<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return 3<br>
&nbsp;&nbsp;&nbsp;&nbsp;elif row.points >= 95:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return 3<br>
&nbsp;&nbsp;&nbsp;&nbsp;elif row.points >= 85:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return 2<br>
&nbsp;&nbsp;&nbsp;&nbsp;else:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return 1<br><br>

star_ratings = reviews.apply(stars, axis='columns')<br><br>

<i>Фильтрация по квантилю</i><br>
q = df.city_index.quantile(0.25) - 25% значений в этой колонке имеют значение q<br><br>

for col in df: - посчитать в % пустые значения в столбце<br>
&nbsp;&nbsp;&nbsp;&nbsp;mis = np.mean(df[col].isnull())<br>
&nbsp;&nbsp;&nbsp;&nbsp;print('{} - {}%'.format(col, round(mis*100)))<br><br>

med = df['name'].median() - заменить пустые знач на среднее<br>
df['name'] = df['name'].fillna(med)<br><br>

<b>Графики</b><br>
df.plot(x='time', y='sales', kind='line', figsize=(10,6), grid=True, style='r')<br>
kind=[plot, area, bar, barh, box, hexbin, hist, kde, density, line, pie, scatter]<br>
rot=15 - развернуть названия на 15 градусовf<br>
df.groupby('education', dropna=False)['target'].mean().plot(kind='bar') - столбчатая диаграмма зависимость от образования<br>
plt.hist(df.Age), plt.show() - гистограмма показывает сколько записей на каждый возраст<br><br>

sns.countplot(data=df, x='workclass')<br>
plt.xticks(rotation=45)<br><br>

plt.hist(df[df['income'] == '>50K']['age'].dropna(), bins=20, alpha=0.5, label='>50K', color='blue')<br><br>

numerical_columns = df.select_dtypes(include=['int64', 'float64']).columns<br>
df[numerical_columns].hist(figsize=(12, 10), bins=20, edgecolor="black")<br>
plt.suptitle("Distribution of Numerical Features", fontsize=16)<br><br>

sns.boxplot(x='education', y='hours-per-week', data=df)<br><br>

distribution = df['marital-status'].value_counts()<br>
plt.pie(distribution, labels=distribution.index, autopct='%1.1f%%', colors=['blue', 'orange', 'green', 'red', 'purple'], startangle=140)<br><br>

***<br>
bargain_idx = (reviews.points / reviews.price).idxmax() - максимальное знач балов к цене (индекс)<br>
bargain_wine = reviews.loc[bargain_idx, 'title'] - по индексу -название вина<br><br>

cols_with_missing = [col for col in X_train.columns if X_train[col].isnull().any()] - выбрать колонки в которых есть пропущенные значения.<br><br>

<i>Игрушечные данные</i><br>
t = pd.DataFrame(dict(col1=[1,2,3,float('nan')],<br>
col2=[0]*3 + [1]*1))<br>
  </section>

  <section id="s13"><h3 align="center">NumPy</h3>

<a href="https://habr.com/ru/articles/469355/" target="_blank" rel="noopener" >NumPy</a> - Нескучный туториал<br><br>
<b>import numpy as np</b><br>
оси массива; axis0, axis1<br>
кортеж индексов (0, 1), ранг (размерность) массива<br>
a = np.array(object, dtype=None) - создать массив<br>
a[0] - получить значение по индексу 0, (присвоить значение)<br>
b = a[[0,0,0,]] - массив из трёх значении a[0]<br>
c = a[[True, True, False]] - массив из элементов <i>a</i>, соответствующие True<br>
d = a.reshape(3,3) - изменить размерность массива<br>
d[1][2] = d[1,2] - значение по индексу - вторая строка, третий столбец<br><br>

y = np.arange(3,12,3) == range(3,12,3); list(y)<br>
x = np.array([a*a for a in y]) - массив из списка<br>
np.random.random(10) - список из 10 случайных значений от 0 до 1<br>
np.random.randint(10) - случайное значение от 0 до 9<br>
[np.random.randint(10)/10 for i in range(5)] - список из  5 случайных значений<br>
height = [int(round(x)) for x in np.random.normal(180, 10, 1000)] - случайные числа (вокруг центра распред), распределённые по нормальному(гауссову) закону (std - стандартное откл.), размер (может быть кортежем для матрицы)<br><br>

np.sqrt(2) - корень из 2<br>
np.radians(135) - 135 градусов в радианах<br>
np.cos(angle_rad) - косинус угла в радианах<br>
np.pi - 3.14<br>
radians = np.deg2rad(degrees)  # Или np.radians(degrees)<br>
degrees = np.rad2deg(radians)  # Или np.degrees(radians)<br><br>

mean = np.mean(data)          # Среднее<br>
median = np.median(data)      # Медиана<br>
Минимальное значение	np.min(data)<br>
Максимальное значение	np.max(data)<br>
Дисперсия	np.var(data)<br>
Квантили	np.quantile(data, [0.25, 0.75])	[5.75, 12.0] (25% и 75%)<br>

np.linspace(-10,10,100) - от -10 до 10 100 точек<br>
np.random.uniform(size=10) / 100 - 10 точек от 0 до 1 делённые на 100<br><br>

det_B = np.linalg.det(B) - определитель матрицы<br>

<b>from scipy import stats</b><br>

mode = stats.mode(data)       # Мода (возвращает объект с values и count)<br>
std = np.std(data)            # Стандартное отклонение<br>

  </section>

  <section id="s14"><h3 align="center">TeX</h3></section>

r"$x\ =\ \frac{\sqrt{144}}{2}\ \times\ (y\ +\ 12)$"<br>
r"$x^2; h_2O$"<br><br>
  </section>

  <section id="s15"><h3 align="center">pywin32</h3>

<i>pip install pywin32</i>; <b>import win32api</b> - модуль для работы с windows<br><br>

<i>pip install py32printing</i>; <b>import win32print</b> - вывод на принтер через windows<br>
  </section>

  <section id="s16"><h3 align="center">threating</h3>

<b>import threading</b> - многопоточный метод<br><br>

def take_a_nap():
&nbsp;&nbsp;&nbsp;&nbsp;time.sleep(5)<br>
&nbsp;&nbsp;&nbsp;&nbsp;print('Wake up')<br><br>

thread_obj = threading.Thread(target=take_a_nap, args=[], kwargs={})<br>
thread_obj.start()<br><br>

В качестве аргументов метод принемает название ф-ции, аргументы ф-ции, ключевые слова в качестве словаря (например: {'sep':';'} для ф-ции print)<br><br>

for thred in all_threads:<br>
&nbsp;&nbsp;&nbsp;&nbsp;tread.join() - чтобы все потоки завршили работу перед завершением работы ф-ции.<br>
print('Done')
  </section>

  <section id="s17"><h3 align="center">geocoder</h3>

<i>pip install geocoder</i>; <b>import geocoder</b><br><br>

city = geocoder.arcgis('city_name')<br>
print(sity.json)<br>
print(sity.json['lat'], sity.json['lng'])<br>
  </section>

  <section id="s18"><h3 align="center">SQL</h3>
    
<a href="https://sqlitebrowser.org" target="_blank" rel="noopener" >DB Browser for SQLite</a><br>
<i>hot key:</i><br>
<i>Ctrl+Enter</i> - выполнить<br>
<a href="https://www.youtube.com/watch?v=TwnCXdCa8qg&list=PLA0M1Bcd0w8x4Inr5oYttMK6J47vxgv6J&index=1" target="_blank" rel="noopener" >SQLite (selfedo)</a><br>
<a href="https://youtu.be/K1C5JAo7cMU?si=dMn764dqVkZZvzRw" target="_blank" rel="noopener" >SQLite (Sweet Coder)</a><br>
<i>SQL</i> - Structured Query Language<br>
<i>СУБД</i> - Система Управления Базой Данных (реляционные базы данных <i>relation</i>)<br>
<i>API</i> - Aplication Progamming Interface

<h5 align="center">SQLite</h5>

<b>import sqlite3 as sq</b><br>
менеджер контекста автоматически подтвердит изменения(commit) и закроет соединение с базой.<br>
<i>with sq.connect("saper.db") as con:</i> - связь(создание) с файлом<br>
&nbsp;&nbsp;&nbsp;&nbsp;<i>cur = con.cursor()</i> - возвращает экземпляр класса 'Cursur'<br>
&nbsp;&nbsp;&nbsp;&nbsp;<i>cur.execute("""query""")</i><br><br>

<i>con.row_factory = sq.Row</i> - если добавить эту строчку вывод будет в виде словаря.<br><br>

другой способ через блок обработки исключений :<br>
con = None<br>
try: - соединение с базой<br>
except sq.Error as e:<br>
&nbsp;&nbsp;&nbsp;&nbsp;if con: con.rollback() - откатывает все изменения (перед загрузкой данных поставить ключевое слово BEGIN)<br>
&nbsp;&nbsp;&nbsp;&nbsp;print("Ошибка выполнения запроса")<br>
finally:
&nbsp;&nbsp;&nbsp;&nbsp;if con: con.close()<br><br>

<i>CREATE TABLE IF NOT EXISTS users (<br>
user_id INTEGER PRIMARY KEY AUTOINCREMENT,<br>
name TEXT NOT NULL,<br>
age INTEGER NOT NULL DEFAULT 1)</i> - создать табл users (в текущем каталоге), если с таким именем нет; поле user_id (с уникальными значениями, увеличивается на 1), поле name (тип данных-строка, дополнительно -  не может быть пустым); поле age (тип данных-целочисленное, по умолчанию не 0, значение=1); REAL-вещественное; BLOB-двоичные; UNIQUE, DEFAULT, NOT NULL, CHECK (age > 0 AND age &lt; 100)<br>
<i>rowid</i> - скрытое поле<br>
<i>cur.lastrowid</i> - какой id был присвоен в последней операции<br>
используем обратные кавычки, если название поля похоже на служебное слово.<br>
<i>DROP TABLE IF EXISTS name</i> - удалить таблицу с именем name<br><br>

<b>внесение, изменение, удаление записей</b><br>
<i>INSERT INTO users (name, gender, age, score) VALUES(Ivan, 1, 20, 1000)</i> - добавить в таблиццу; название полей (если все - можно не указывать; значения для ввода)<br>
<i>INSERT INTO users DEFAULT VALUES;</i> - столбцы, для которых определены значения  по умолчанию и нет NOT NULL, получат эти значения; остальные NULL<br>
<i>INSERT INTO users (name, age) VALUES</i><br>
<i>('Tom', 37), ('Bob', 34)</i> - добавить две строки<br>
Загрузить данные из коллекции (список кортежей); колелекция cars; поля - id INTEGER PRIMARY KEY AUTOINCREMENT, model, price.<br>
query = """INSERT INTO cars VALUES(NULL, ?, ?)"""<br>
for car in cars:<br>
&nbsp;&nbsp;&nbsp;&nbsp;cur.execute(query, car)<br><br>

<i>cur.executemany(query, cars)</i> - метод перебирает коллекцию.<br><br>

<i>query = """ UPDATE cars SET price = :Price WHERE model LIKE 'A%' """</i><br>
<i>cur.execute(query, {Price: 0})</i> - использование именованого параметра; имя параметра Price; и словарь со значениями для моделей начинающихся с A<br><br>

<i>query = """ DELETE FROM cars WHERE model LIKE 'A%';</i><br>
<i>UPDATE cars SET price = price=1000"""</i><br>
<i>cur.executescript(query)</i> - выполнить несколько команд (удалить все модели начинающиеся с 'А', а у остальных добавить 1000 к ценнику); с этим методом не используются шаблоны.<br><br>
<i>UPDATE users SET score = score+500, age=30  WHERE rowid = 1</i> (WHERE name LIKE 'Ivan'; <i>'_'</i> - любой символ, <i>'%'</i> - любое продолжение строки )<br>
<i>DELETE FROM users WHERE rowid IN(2,5)</i> - удалить записи 2 и 5<br><br>

<i>ORDER BY age</i> - сортировать по возростанию (ASC)<br>
<i>ORDER BY age DESC</i> - сортировать по убыванию<br>
<i>LIMIT max [OFFSET offset]</i> - выбрать столько строк [столько пропустить]<br>
<i>LIMIT offset, max</i> - тоже через зпт<br>
print(<i>cur.fetchall()</i>) - вывести результат (список кортежей)<br>
<i>fetchmany(size), fetchone()</i> - вывести определённое кол-во, одну запись<br>
или по строчно:<br>
<i>for result in cur</i><br>
&nbsp;&nbsp;&nbsp;&nbsp;print(result)<br>
print(cur.rowcount) - кол-во строк в таблице<br><br>

<b>изменение таблицы</b><br>
<i>ALTER TABLE users RENAME TO people</i> - переименовать таблицу<br>
<i>ALTER TABLE users ADD COLUMN email  TEXT NOT NULL</i> - добавим столбец с ограничением<br>
<i>ALTER TABLE users RENAME COLUMN email TO login</i><br>
<i>ALTER TABLE users DROP COLUMN login</i><br><br>

<b>фильтрация данных. WHERE</b><br>
<i>SELECT name, age, score FROM users</i>; (SELECT *) - выбрать всё<br>
<i>SELECT * FROM users WHERE score &lt; 1000</i> - выбрать всё где <i>score</i> &lt; 1000<br>
<i>SELECT * FROM users WHERE score BETWEEN 500 AND 1000</i> - числа включены<br>
<i>SELECT * FROM users WHERE name LIKE 'Ivan'</i><br>
приоритет: NOT, AND, OR<br>
<i>SELECT name, prod_count * price AS total_sum FROM products</i> - в таблице есть три поля; выбрать поле name и поле, которое будет содержать  произведение двух других полей с новым названием<br>
<i>SELECT rowid,* FROM users</i> - показать поле rowid <br><br>

<b>Агрегирование и группировка GROUP BY</b><br>
<i>SELECT count(user_id) FROM users WHERE user_id = 1</i> - кол-во строк с user_id = 1<br>
<i>SELECT count(user_id) as count FROM users WHERE user_id = 1</i> - выбрать синоним (alias) для поля (чтобы не выводилось count(user_id))<br>
<i>count(), sum(), avr(), min(), max()</i> - кол-во, сумма, среднее арифетическое, минимальное и максимальное значения.<br>
<i>DISTINCT</i> - уникальные значения<br>
<i>SELECT count(DISTINCT name) as names FROM users</i><br><br>

<i>SELECT user_id, sum(score) as sum</i> - выбираем поле user_id, подсчитываем сумму очков для каждого игрока, название  для созданного поля sum<br>
<i>FROM usrs</i><br>
<i>CROUP BY user_id</i><br><br>

<b>JOIN</b><br>
<i>SELECT name, gender, games.score FROM games</i><br>
<i>JOIN users ON games.user_id=users.rowid</i> - условие связывания: внешний ключ = первичному ключу<br>
<i>LEFT JOIN</i> - возьмёт левую таблицу полностью и даже если нет соответствий  с правой.<br><br>

<b>UNION</b> - объеденит толлько уникальные записи<br>
<i>SELECT name1, name2 FROM table1</i><br>
<i>UNION SELECT name3, name4 FROM table2</i><br><br>

<b>загрузка картинок в таблицу</b> (кактинки в папке 'avas'; 1.png, 2.png...; в созданной таблице user_img поля id, name, ava BLOB)<br>
<i>def readAva(n):</i><br>
&nbsp;&nbsp;&nbsp;&nbsp;<i>try:</i><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<i>with open(f"avas/{n}.png", 'rb') as f:</i><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<i>return f.read()</i><br>
&nbsp;&nbsp;&nbsp;&nbsp;<i>except IDError as e:</i><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<i>print(e)</i><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<i>return False</i><br><br>

<i>img = readAva(1)</i><br>
<i>if img:</i><br>
&nbsp;&nbsp;&nbsp;&nbsp;<i>binary = sq.Binary(img)</i><br>
&nbsp;&nbsp;&nbsp;&nbsp;<i>query = """INSERT INTO users VALUES (NULL, 'Joe', ?)"""</i><br>
&nbsp;&nbsp;&nbsp;&nbsp;<i>cur.execute(qyery, (binary,))</i><br><br>

<b>сохранение картинки из таблицы в cwd</b><br>
<i>def writeAva(name, data):</i><br>
&nbsp;&nbsp;&nbsp;&nbsp;<i>try:</i><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<i>with open(name, 'wb') as f:</i><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<i>f.write(data)</i><br>
&nbsp;&nbsp;&nbsp;&nbsp;<i>except IDError as e:</i><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<i>print(e)</i><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<i>return False</i><br>
&nbsp;&nbsp;&nbsp;&nbsp;return True<br><br>

(db.row_factory = sq.Row) - добавим метод, чтобы вызывать название поля как ключ словаря<br>
<i>cur.execute("""SELECT ava FROM user_img LIMIT 1""")</i><br>
<i>img = cur.fetchone()['ava']</i><br>
<i>writeAva("name.png", img)</i> - записали изображение в cwd  как 'name.png'<br><br>

<b>Дата и время</b><br>
<i>SELECT</i><br>
<i>date(time-value, modifier, modifier,..) AS date</i>,<br>
<i>time() AS time</i>,<br>
<i>datetime() AS datetime,</i><br>
<i>datetime(1092941466),</i> - дней с начала юлианской эпохи (INTEGER или REAL)<br>
<i>julianday() AS julian,</i> - дней с начала юлианского периода (24 ноября 4714 до н.э.)<br>
<i>strftime(format, time-valum, modifier, modifier..)</i><br><br>

Если не передаются параметры (или стоит 'now'), то они возвращают текущие дату и время.<br>
<i>YYYY-MM-DD HH:MM:SS.SSS</i> - параметр time-value, может между датой и временем быть разделитель 'T'<br>
модификаторы:<br>
<i>SELECT date('now', '-2 days', '1 months', '3 hours', '35 miutes', '-45.1 seconds', '11 years'),</i> - к текущей дате прибавить месяц, отныть 2 дня..<br>
<i>'start of month', 'start of year', 'start of day'</i> - вернуть в начало месяца, года, дня<br>
<i>'weekday 0', 'weekday 1'..</i> - сдвинуть на воскр, понедельник..<br>
<i>unixepch</i> - возвращает кол-во секунд с эпохи  UNIX (только с форматом 'DDDDDDDDDD')<br>
<i>localtime</i> - местное время<br>
<i>uts</i> - UTC<br><br>
<i>Форматирование дат и времени</i>
<table>
  <tr><td>%d</td><td> - день месяца в формате 00</td></tr>
  <tr><td>%f</td><td> - секунды в формате  SS.SSS</td></tr>
  <tr><td>%H</td><td> - час в формате 00-24</td></tr>
  <tr><td>%j</td><td> - день года в формате 001-366</td></tr>
  <tr><td>%J</td><td> - дней с начала юдианской эпохи</td></tr>
  <tr><td>%m</td><td> - месяц в формате 01-12</td></tr>
  <tr><td>%M</td><td> - минута в формате 00-59</td></tr>
  <tr><td>%s</td><td> - секунд с 1970-01-01</td></tr>
  <tr><td>%S</td><td> - секунды в формате 00-59</td></tr>
  <tr><td>%w</td><td> - день недели в формате 0-6 (0 - вск)</td></tr>
  <tr><td>%W</td><td> - номер недели года в формате 00-53</td></tr>
  <tr><td>%Y</td><td> - год в формате 0000-9999</td></tr>
  <tr><td>%%</td><td> - экранирует символ '%'</td></tr>
</table>
<i>SELECT strftime('%d.%m.%Y', '2021-12-01');</i> - 01.12.2021<br><br>

сохранять дату можно с типом TEXT,<br>
или с типом  REAL - тогда будет сохранено кол-во дней с начала юлианской эпохи.<br>
<i>SELECT date_time,  datetime(date_time) FROM users</i> - поле date_time сохранено с типом REAL, второе поле возвращает обычную дату<br><br>

сохранение даты в виде timestemp<br>
def get_timestamp(y, m, d):<br>
&nbsp;&nbsp;&nbsp;&nbsp;return dt.datetime.timestamp(dt.datetime(y, m, d))<br><br>

def get_date(tmstmp):<br>
&nbsp;&nbsp;&nbsp;&nbsp;return dt.datetime.fromtimestamp(tmstmp).date()<br><br>

<b>Создание бэкапа БД</b><br>
открываем  БД; записываем её в файл 'sql_damp.sql'<br>
with sq.connect("cars.db") as con:<br>
&nbsp;&nbsp;&nbsp;&nbsp;cur = con.cursor()<br><br>

&nbsp;&nbsp;&nbsp;&nbsp;with open('sql_damp.sql', 'w') as f:<br>
&nbsp;&nbsp;&nbsp;&nbsp;for sql in con.iterdump():<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;f.write(sql)<br><br>

Для восстановления БД открываем файл 'sql_damp.sql' для чтения; и запускаем executescript()<br>
sql = f.read()<br>
cur.executescript(sql)<br>

import string; string.ascii_letters<br><br>

pip install faker; import faker; fake = faker.Faker(); fake.name() - произвольное имя<br>
[fake.name for i in range(15)]<br>

</section>

<section id="s19"><h5 align="center">BigQuery</h5>

<a href="https://cloud.google.com/bigquery?hl=ru" target="_blank" rel="noopener" >BigQuery</a><br>
<i>from google.cloud import bigquery</i><br>
<i>client</i> - содержит проекты и связь с BigQuery<br>
<i>проект</i> - содержит датасеты<br>
<i>датасет</i> - содержит коллекцию таблиц<br>
<i>таблица</i> - содержит информацию по каждому полю (название, тип данных, режим, описание)<br><br>

<i>client = bigquery.Client()</i> - создаём объект client()<br>
<i>dataset_ref = client.dataset("hacker_news", project="bigquery-public-data")</i> - доступ к датасету; название и соответствующий проект<br>
<i>dataset = client.get_dataset(dataset_ref)</i> - коллекция таблиц<br><br>

tables = list(client.list_tables(dataset)) - получить список таблиц в датасете<br>
for table in tables: - получить имена таблиц<br>
&nbsp;&nbsp;&nbsp;&nbsp;print(table.table_id)<br><br>

list_of_tables = [table.table_id for table in list(client.list_tables(dataset))]<br><br>

table_ref = dataset_ref.table('full') - доступ к таблице название 'full'<br>
table = client.get_table(table_ref)<br><br>

<i>Table schema</i><br>
table.schema - (SchemaField) инфорамация о всех столбцах таблицы (fields). name, field type, mode (NULLABLE) - допускается значение NULL, description<br><br>

client.list_rows(table, max_results=5).to_dataframe() - вывезти первые пять строк в df.<br>
client.list_rows(table, selected_fields=table.schema[:1], max_results=5).to_dataframe() - только первый столбец<br><br>

<i>SELECT ... FROM</i><br>
query = """ # запрос  - выбор столбца 'Name'  из таблицы 'pets', 'pet_records' - датасет, 'bigquery-public-data - проект, где в столбце  'Animal' = 'Cat'<br>
SELECT Name # название полей через зпт.(* - все поля)<br>
FROM `bigquery-public-dada.pet_records.pets` # в обратных ковычках (backticks)<br>
WHERE Animal = 'Cat' # условие (clause) <br>
"""<br><br>

SELECT DISTINCT country (уникальные значения в колонке)<br>
WHERE Name LIKE '%ipl%' # % - wildcard<br><br>

<b>Submiting the query to the dataset</b> - отправка запроса<br>
query_job = client.query(query)<br>
us_cities = query_job.to_dataframe() - запрос - города US из OpenAQ dataset<br>
us_cities.city.value_counts().head() - df 'us_cities', column 'city', кол-во значений.<br><br>

<b>Kaggle</b> - лимит на скачивание датасетов 5ТБ в месяц<br>
dry_run_config = bigquery.QueryJobConfig(dry_run=True) - создаём объект для расчёта объёма запроса<br>
dry_run_query_job = client.query(query, job_config=dry_run_config)<br>
print("This query will process {} bytes.".format(dry_run_query_job.total_bytes_processed)) - кол-во байтов<br><br>

# Only run the query if it's less than 1 MB<br>
ONE_MB = 1024*1024 (1024*1024*1024 = 1Gb)<br>
safe_config = bigquery.QueryJobConfig(maximum_bytes_billed=ONE_MB)<br><br>

# Set up the query (will only run if it's less than 1 MB)<br>
safe_query_job = client.query(query, job_config=safe_config)<br><br>

# API request - try to run the query, and return a pandas DataFrame<br>
safe_query_job.to_dataframe() - выдаст ошибку если больше заявленого<br><br>

<b>GROUP BY, HAVING & COUNT</b><br>
<i>aggregate function</i> - takes many values and returns one.(COUNT(ID), SUM(),AVG(), MIN(), MAX()); возвращает колонку f0__<br>
query = """SELECT Animal, COUNT(ID) # (COUNT(1) AS NameColumns) - считать строки, переименовать колонку<br>
FROM `bigquery-public-data.pet_records.pets`<br>
GROUP BY Animal # - посчиатать кол-во каждого животного<br>
HAVING COUNT(ID) > 1""" # - при условии - больше одного<br><br>

`by` AS author - если название стобца совпадает с каким-нибудь ключевым словом - берём в обратные ковычки и лучше заменить название<br><br>

<b>ORDER BY</b> - сортирует числа или текст в алфавитном порядке<br>
SELECT ID, Name, Animal<br>
FROM `bigquery-public-data.pet_records.pets`<br>
ORDER BY Animal DESC # (descending - убывание)<br><br>

<b>Dates</b><br>
<a href="https://cloud.google.com/bigquery/docs/reference/legacy-sql#datetimefunctions" target="_blank" rel="noopener" >Date and time functions</a><br>
There are two ways that dates can be stored in BigQuery: as a DATE or as a DATETIME.<br>
DATE - YYYY-[M]M-[D]D<br>
DATETIME - YYYY-[M]M-[D]D + ВРЕМЯ<br><br>

<b>EXTRACT</b><br>
SELECT name, EXTRACT(DAY from Date) AS Day # выбрать имя и день из колонки 'Date'<br>
Посчитать кол-во ДТП по дням недели:<br>
query = """SELECT COUNT(consecutive_number) AS num_accidents, EXTRACT(DAYOFWEEK FROM timestamp_of_crash) AS day_of_week<br>
FROM `bigquery-public-data.nhtsa_traffic_fatalities.accident_2015`<br>
GROUP BY day_of_week<br>
ORDER BY num_accidents DESC""" # сортировать в порядке убывания(1 - Sunday, 7 - Saturday)<br><br>

WHERE indicator_code = 'SE.XPD.TOTL.GD.ZS' and year &gt;= 2010 and year &lt;= 2017<br><br>

<b>WITH ... AS</b><br>
<i>A common table expression</i> (or CTE) is a temporary table that you return within your query.<br><br>

query_with_CTE = """ WITH time AS (<br>
SELECT DATE(block_timestamp) AS trans_date # ф-ция DATE  возвращает дату из datetime()<br>
FROM `bigquery-public-data.crypto_bitcoin.transactions`)<br>
SELECT COUNT(1) AS transactions, trans_date # считаем кол-во трансакций по дням.<br>
FROM time<br>
GROUP BY trans_date<br>
ORDER BY trans_date"""<br><br>

<i>посчитаем среднюю скорость за час в поездках за 3 месяца и не нулевые</i><br>
WITH RelevantRides AS(<br>
SELECT EXTRACT(HOUR FROM trip_start_timestamp) AS hour_of_day, trip_miles,trip_seconds<br>
FROM `bigquery-public-data.chicago_taxi_trips.taxi_trips`<br>
WHERE trip_start_timestamp > '2016-01-01' AND trip_start_timestamp < '2016-04-01'<br> AND trip_seconds > 0 AND trip_miles > 0)<br>
SELECT hour_of_day, COUNT(1) AS num_trips, <br>
3600 * SUM(trip_miles) / SUM(trip_seconds) AS avg_mph<br>
FROM RelevantRides<br>
GROUP BY hour_of_day<br>
ORDER BY hour_of_day<br><br>

<b>Joining Data</b><br>
# объеденить таблицу собственников животных (как о) с таблицей самих животных по номеру ID. (только пересекающиеся множества)<br>
SELECT o.Name AS Owner_Name, p.Name AS Pet_Name<br>
FROM `bigquery-public-data.pet_records.owners` AS o<br>
INNER JOIN `bigquery-public-data.pet_records.pets` AS p<br>
ON p.ID = o.Pet_ID<br><br>

LEFT JOIN, RIGHT JOIN, FULL JOIN - строки не имеющие совпадения будут иметь значение NULL<br>
UNION ALL - конкатенация колонок вертикально (со всеми повторениями)<br>
UNION DISTINCT - без повторений<br><br>

# все посты на 1 января с количеством комментариев<br>
WITH c AS(<br>
SELECT parent, COUNT(*) as num_comments<br>
FROM `bigquery-public-data.hacker_news.comments` <br>
GROUP BY parent)<br>
SELECT s.id as story_id, s.by, s.title, c.num_comments<br>
FROM `bigquery-public-data.hacker_news.stories` AS s<br>
LEFT JOIN c ON s.id = c.parent<br>
WHERE EXTRACT(DATE FROM s.time_ts) = '2012-01-01'<br>
ORDER BY c.num_comments DESC<br><br>

# время между появлением вопроса и первого комента<br>
SELECT q.id AS q_id,<br>
MIN(TIMESTAMP_DIFF(a.creation_date, q.creation_date, SECOND)) as time_to_answer<br>
FROM `bigquery-public-data.stackoverflow.posts_questions` AS q<br>
LEFT JOIN `bigquery-public-data.stackoverflow.posts_answers` AS a<br>
ON q.id = a.parent_id<br>
WHERE q.creation_date >= '2018-01-01' and q.creation_date &lt; '2018-02-01'<br>
GROUP BY q_id<br>
ORDER BY time_to_answer<br><br>

first_result = client.query(first_query).result().to_dataframe()<br>
print("Percentage of answered questions: %s%%" % \<br>
      (sum(first_result["time_to_answer"].notnull()) / len(first_result) * 100))<br>
print("Number of questions:", len(first_result))<br><br>

<b>Analyic Functions</b> (windows functions calls)<br>
# разделить на группы; сортировать по дате; посчитать среднее значение между двумя соседними значениями (window frame)<br>
SELECT *, AVG(time)OVER(<br>
PARTITION BY id <br>
ORDERD BY date <br>
ROWS BETWEEN 1 PRECEDING AND CURRENT ROW) as avg_time<br><br>

ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING - all rows in the partition.<br><br>

<i>Analytic aggregate functions</i>: MIN() or MAX(), AVG() or SUM(), COUNT()<br>
<i>Analytic navigation functions</i>: FIRST_VALUE() or LAST_VALUE(), LEAD() and LAG()<br>
<i>Analystic numbering functions</i>: ROW_NUMBER(), RANK()<br><br>

# Query to track beginning and ending stations on October 25, 2015, for each bike<br>
start_end_query = """SELECT bike_number,<br>
    TIME(start_date) AS trip_time,<br>
    FIRST_VALUE(start_station_id)<br>
        OVER (PARTITION BY bike_number<br>
              ORDER BY start_date<br>
              ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING<br>
              ) AS first_station_id,<br>
    LAST_VALUE(end_station_id)<br>
        OVER (PARTITION BY bike_number<br>
              ORDER BY start_date<br>
              ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING<br>
              ) AS last_station_id,<br>
    start_station_id,<br>
    end_station_id<br>
FROM `bigquery-public-data.san_francisco.bikeshare_trips`<br>
WHERE DATE(start_date) = '2015-10-25' <br>
"""<br>
# Run the query, and return a pandas DataFrame<br>
start_end_result = client.query(start_end_query).result().to_dataframe()<br><br>

# Датасет Чикаго такси; добавить колонку в которой время (в мин) между завершением заказа и началом следующего.<br>
break_time_query = """SELECT taxi_id,<br>
  trip_start_timestamp,<br>
  trip_end_timestamp,<br>
  TIMESTAMP_DIFF(trip_start_timestamp, <br>
    LAG(trip_end_timestamp, 1) <br>
  OVER (PARTITION BY taxi_id <br>
        ORDER BY trip_start_timestamp), MINUTE) as prev_break<br>
FROM `bigquery-public-data.chicago_taxi_trips.taxi_trips`<br>
WHERE DATE(trip_start_timestamp) = '2013-10-03' <br>
"""<br><br>

<b>Nested and Repeated Data</b><br>
# табл. с животными и табл. с их игрушками; собираем в одну табл. причём в колонке 'Toy' собрана инфо из двух колонок - вложеная колонка (<ins>nested columns</ins> have type STUCT or RECORD)<br>
<i>SchemaField('Toy', 'RECORD', 'NULLABLE', None, (<br>
  &#160;&#160;&#160;SchemaField('Name', 'STRING', 'NULLABLE', None, ())<br>
  &#160;&#160;&#160;SchemaField('Type', 'STRING', 'NULLABLE', None, ())))</i><br><br>

SELECT Name AS Pet_Name, Toy.Name AS Toy_Name, Toy.Type AS Toy_type<br><br>

# в табл. с игрушками несколько игрушек для одного животного - повторяющиеся данные; тогда в схеме таблице для колонки 'Toys' mode = 'REPEATED' - <ins>repeated data</ins><br>
<i>SchemaField('Toys', 'STRING', 'REPEATED', None, ())</i><br><br>

<b>Writing Efficient Queries</b><br>
from time import time<br>
client = bigquery.Client()<br><br>

def show_amount_of_data_scanned(query):<br>
&#160;&#160;&#160;# dry_run lets us see how much data the query uses without running it<br>
&#160;&#160;&#160;dry_run_config = bigquery.QueryJobConfig(dry_run=True)<br>
&#160;&#160;&#160;query_job = client.query(query, job_config=dry_run_config)<br>
&#160;&#160;&#160;print('Data processed: {} GB'.format(round(query_job.total_bytes_processed / 10**9, 3)))<br><br>
    
def show_time_to_run(query):<br>
&#160;&#160;&#160;time_config = bigquery.QueryJobConfig(use_query_cache=False)<br>
&#160;&#160;&#160;start = time()<br>
&#160;&#160;&#160;query_result = client.query(query, job_config=time_config).result()<br>
&#160;&#160;&#160;end = time()<br>
&#160;&#160;&#160;print('Time to run: {} seconds'.format(round(end-start, 3)))<br><br>

* Only select the columns you want<br>
* Read less data<br>
* Avoid N:N JOINs (объединение болших массивов)<br>
  </section>

  <section id="s20"><b>import subprocess</b><br>
subprocess.Popen('C:\\Windows\\System32\\calc.exe') - калькулятор<br>
paintProc = subprocess.Popen('c:\\Windows\\System32\\mspaint.exe') - paint<br>
paintProc.poll() - вернёт 0, если процесс завершен без ошибок<br>
paintProc.wait()<br>
subprocess.Popen(['C:\\Windows\\notepad.exe', \
                'C:\\Users\\zradi\\Documents\\my_py\\avto_rem\\avto_rem.txt']) - запустить блокнот и текстовый файл<br>
  </section>

  <section id="s21"><i>pip install colorama</i><br>
<a href="https://pypi.org/project/colorama/" target="_blank" rel="noopener" >colorama</a> - раскрасить 'print' (не работает в IDLE)<br><br>

from colorama import init, Fore, Back, Style<br>
init()<br>
print(Fore.RED + "Ошибка!" + Style.RESET_ALL)<br>
print(Fore.GREEN + "Успех!" + Style.RESET_ALL)<br>
print(Back.CYAN + "Сообщение" + Style.RESET_ALL)<br>
print(Style.BRIGHT + "Важное предупреждение" + Style.RESET_ALL)<br><br>

init(autoreset=True)  # Теперь не нужно вручную добавлять RESET<br>
print(Fore.RED + "Этот текст красный")<br><br>
  </section>

  <section id="s22"><i>pip install translatepy</i><br>
<a href="https://pypi.org/project/translatepy/" target="_blank" rel="noopener" >translatepy</a> - переводчик<br><br>

from translatepy import Translator<br>
translator = Translator()<br>
print(translator.translate("Hello", "rus"))<br><br>
  </section>

      </aside>
    </div>
  </div>
</body>
</html>