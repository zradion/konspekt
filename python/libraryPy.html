<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="../css/style1.css" />
    <title>libraryPy</title>
</head>
<body>
    <div class="cont">
        <div class="left_right">
            <aside class="left">
    <p><a href="../index.html"><img src="../img/icon-home.png" alt="home"></a></p>
    <p><a href="#s0"><img src="../img/arrow-top.png" alt="arrow-top"></a></p>
     <p><i>Встроенные модули</i></p>
    <p><a href="#s1">random</a></p>
    <p><a href="#s2">sys</a></p>
    <p><a href="#s3">time</a></p>
    <p><a href="#s4">datetime</a></p>
    <p><a href="#s5">copy</a></p>
    <p><a href="#s6">math</a></p>
    <p><a href="#s7">Regex</a></p>
    <p><a href="#s8">pandas</a></p>
    <p><a href="#s9">pathlib</a></p>
    <p><a href="#s10">os</a></p>
    <p><a href="#s11">shutil</a></p>
    <p><a href="#s12">zipfile</a></p>
    <p><a href="#s13">shelve</a></p>
    <p><a href="#s14">pprint</a></p>
    <p><a href="#s15">csv</a></p>
    <p><a href="#s16">pickle</a></p>
    <p><i>Сторонние модули</i></p>
    <p><a href="#s50">pyperclip</a></p>
    <p><a href="#s51">requests</a></p>
    <p><a href="#s52">BeautifulSoup</a></p>
    <p><a href="#s53">selenium</a></p>
    <p><a href="#s54">pyinputplus</a></p>
    <p><a href="#s55">lxml</a></p>
    <p><a href="#s56">win32</a></p>
    <p><a href="#s57">send2trash</a></p>
    <p><a href="#s58">pprint</a></p>
    <p><a href="#s59">pass</a></p>
    <p><a href="#s99">Ссылки.</a></p>            
            </aside>
    
            <aside class="right"><h1 align="center" id="s0">Library for Python.</h1>
                <h3 align="center">Встроенные модули:</h3>
  <section id="s1">
<b>import random</b><br>
<i>random.randint(a, b)</i> - случайное число от a до b, включая оба<br>
<i>random.choise([list])</i> - слуачайное значение из списка<br>
<i>random.choice(list(range(20)))</i> - случайное из 20<br>
<i>random.shuffle(list)</i> - перемешать список (на месте)<br>
<i>a = random.sample(list, 3)</i> - вернёт список из трёх рандомных значений<br>
<i>random.uniform(0,1)</i> - число от 0 до 1<br>
  </section>  

  <section id="s2">
<b>import sys</b><br>
<i>sys.exit()</i> (Try, except; Ctrl+c - выход без выброса ошибки)<br>
  </section>

  <section id="s3">
<b>import time</b><br>
time.time() - время в секундах с начала эпохи(1970-01-01 12:00:00)<br>
time.ctime() - UTC - Thu Aug 31 15:52:18 2023<br>
<i>time.sleep(1)</i> - задержка 1с<br>
  </section>

  <section id="s4">
<b>import datetime</b>; import datetime as dt<br>
Классы: date, time, datetime<br>
<i>.date</i><br>
date(year, month, day)<br>
print(datetime.date(2023,8,31)) .. 2023-08-31<br>
today = datetime.date.today() .. 2023-08-31<br>
print(f"{today.day}.{today.manth}.{today.year}") .. 31.8.2023<br><br>

<i>.time</i><br>
time([hour][, min][, sec][, microsec]) (без параметров 0:0:0)<br>
print(datetime.time(10,47,20)) .. 10:47:20<br><br>

<i>.datetime</i><br>
datetime(year, month, day [, hour][, min][, sec][, microsec])<br>
print(datetime.datetime(2023,8,31)) .. 2023-08-31 00:00:00<br>
now = datetime.datetime.now()<br> ..2023-08-31 10:58:03.968252<br>
now.date; now.month; now.year; now.hour, now.minute, now.microsecond<br><br>

<i>strptime(str, format)</i> - распарсить строку; преобразовать в дату<br>
%d; %m; %y; %Y; %H; %M; %S - день; номер месяца; год (две цифры); год (4 цифры); час; минута; секунда<br>
deadline = datetime.datetime.strptime("05-22-2017 12:30", "%m-%d-%Y %H:%M")<br>
print(deadtime) .. 2017-05-22 12:30:00<br><br>

<i>strftime(format)</i> - для объектов <i>date</i> и <i>time</i>; принимает один параметр - формат<br>
%a - Wed; %A - Wednesday; %b - Oct; %B - October<br>
%d - 01(день); %m - 05(месяц); %y - 23; %Y - 2023<br>
%H - 13(часов); %I - 01(час); %M; %S; %f - микросекунда<br>
%p - AM/PM; %c - дата и время местный формат<br>
%x; %X - дата; время - местный формат<br>
print(now.strftime("%d %b (%A)")) .. 31 Aug (Thursday)<br><br>

<i>import locale</i><br>
<i>locale.setlocale(locale.LC_ALL, "")</i> - для использования русских(местных) слов<br><br>

from datetime import timedelta<br>
<i>timedelta([days][, seconds][, microseconds][, milliseconds][, minutes][, hours][, weeks])</i> - класс;<br>
three_hours = timedelta(hours=3, minutes=25) .. 3:25:00<br>
two_days = timedelta(2, 25) .. 2 days, 0:00:25<br>
delta = three_hours + two_days .. 2 days, 3:25:25<br><br>

методы: <i>days, seconds, microseconds, total_seconds()</i><br>
delta.seconds; delta.total_seconds()<br><br>

if now > deadline:<br>
&nbsp;&nbsp;&nbsp;&nbsp;print("Time is over")<br>
elif now.day == deadline.day and now.month == deadline.month:<br>
&nbsp;&nbsp;&nbsp;&nbsp;print("today")<br>
else:
&nbsp;&nbsp;&nbsp;&nbsp;period = deadline - now<br>
&nbsp;&nbsp;&nbsp;&nbsp;print(f"осталось {period.days} дней")<br>
  </section>

  <section id="s5">
    <b>import copy</b><br>
<i>copy.copy(test)</i> - поверхносная копия<br>
<i>copy.deepcopy(test)</i> - глубокое копирование<br>
  </section>

  <section id="s6">
    <b>import math</b><br>
    math.pi<br>
    math.ceil(5.2) .. 6<br>
    math.floor(5.99) .. 5<br>
    .sqrt(); .sin(); .cos();<br>
  </section>

  <section id="s7">
    <b>import re</b><br>
Regular expressions (regexes)<br>
Специальные символы: <b>\ . $ ? + * {} [] () | </b> - надо экранировать (\) или использовать сырую строку (r"txt")<br>
pattern = <i>re.compile</i>(r'\d{3}) - pattern передаём в  re.compile() и сохраняем в regex object<br>
result = <i>re.match</i>(r"word", txt) - только в начале строки<br>
result = <i>pattern.search</i>(txt).group()<br>
result = <i>re.search</i>(r"word", txt)[0] - первое совпадение<br>
print(result[0] if result else 'NO')<br><br>

<i>re.fullmatch</i>(pattern, string) - проверить полное совпадение под шаблон<br>
print('Yes' if result else 'No')<br>
re.search, re.fullmatch - возвращают match-объект или None<br>
<i>result.group() или result[0]</i> - всё совпадение; в скобках можно указать группу или группы через зпт<br>
<i>result.group<b><ins>s</ins></b>()</i> - вернёт кортеж из всех групп; можно исп множественное присвоение для разных частей патерна<br>
<i>result.start(), result.end(), result.lastindex</i> - позиция начала совпадения, следующий после, последний индекс группы(кол-во групп); в скобках номер групы; если не находит -1<br>
<i>result.span(0)</i> - кортеж начальной и конечной позиции.<br>
<i>result.re </i>- компелированный шаблон.<br>
<i>result.string </i>- анализируемая строка.<br><br>

text = "&lt;font color=#CC0000>"<br>
result = re.search(r"(?P&lt;key>\w+)=(?P&lt;volue>#[\da-fA-F]{6})\b", text) - именованые группы key and volue.<br>
<i>result.groupdict()</i> .. {'key': 'color', 'volue': '#CC0000'}<br>
result.expand(r"\g&lt;key> :\g&lt;volue>") .. color: #CC0000<br>
<i>result.expand</i>(r"\1 :\2") .. color: #CC0000<br><br>

<i>re.findinter</i> - то же, что и search, только исп в циклах для нахождения всех совпадений.<br><br>

Сохраняющие скобки (при search, fullmatch and finditer) не изменяют вывод, но можно получить инфо по каждой группе (если не используется квантификатор; тогда только для последнего соответсвия).<br>
Нумерация в группах: pattern = r"((\d)(\d))((\d)(\d))<br>
0 - весь шаблон; 1 - первые две цифры; 2 - первая цифра; 3 - вторая; 4 - вторые две цифры; 5 - третья цифра; 6 - четвёртая<br>
match = re.search(r"\s*([А-Яа-яЁё]+)(\d+)\s*", r"--Опять45--")<br>
print(match[0], <i>match.start</i>(0), <i>match.end</i>(0)) - весь шаблон<br>
print(match[1], match.start(1), match.end(1)) - первая группа<br>
print(match.group(1,2,3)) - кортеж из групп<br><br>

<i>re.split</i>(pattern, string, maxsplit=0) - разделение по подстрокам, подходящим под шаблон<br>
print(re.split(r"\W+", "Где скажите мне, мои очки?"))
... ["Где", "скажите", "мне", "мои", "очки"]<br>

<i>re.findall</i>(pattern, string) - вернёт список строк, если нет групп и список кортежей, если есть (все непересекающиеся шаблоны).<br>
result = re.findall(r"стеклянн?ый", text) - вернёт список всех совпадений.<br>
result = re.findall(r"(\w+)\s*=\s*([^;]+)", text) - группа букв.цифр до ,возможно, прбелов; потом =; возможно пробелы; любые символы кроме ';'<br>
print(result)<br><br>

<i>re.finditer</i>(pattern, string) - итератор по непересекающимся шаблонам<br><br>

<i>re.sub</i>(pattern, repl, string, count=0) - заменить все непересекающиесся шаблоны на repl<br>
result2 = re.sub(r"old", r"new", txt) - заменить<br>
второй аргумент может быть имя ф-ции.<br><br>

text = "Moscow Saint-Petersburg Novgorod"<br>
result2 = re.sub(r"\s*[\w-]+\s*", r"&lt;option>\1&lt;/option>\n", text)<br>
print(result2)<br><br>

count = 0<br>
def replFind(m): # аргумент - объект Match<br>
&nbsp;&nbsp;&nbsp;&nbsp; global count<br>
&nbsp;&nbsp;&nbsp;&nbsp; count += 1<br>
&nbsp;&nbsp;&nbsp;&nbsp; return f"&lt;option value='{count}'>{m.group(1)}&lt;/option>\n"<br>
result2 = re.sub(r"\s*[\w-]+\s*", replFind, text)<br>
.. &lt;option value='1'>Moscow&lt;option>...<br><br>

Использование групп при замене:<br>
Можно ссылаться на соответсвующую группу при помоощи \1, \2, ...(если групп больше 9, то \g<12>)<br>
print(re.sub(r"(\d\d)/(\d\d)/(\d{4})", r"\2.\1.\3", "03/25/2023")) - дата по амер; вернёт в нормальном порядке через точку<br><br>


Символьные классы: [A-z][0-9] // одна буква и одна цифра; спец символы здесь не работают(кроме \)<br>
<table>
  <tr><td><b>.</b></td><td>любой символ; кроме \n; с флагом re.DOTALL - весь текст (wildcard)</td></tr>
  <tr><td><b>\d</b></td><td>любая цифра [0-9]</td></tr>
  <tr><td><b>\D</b></td><td>любой не цифровой символ [^0-9]</td></tr>
  <tr><td><b>\s</b></td><td>любой пробельный символ [\t\n\r\f\v]</td></tr>
  <tr><td><b>\S</b></td><td>любой непробельный символ</td></tr>
  <tr><td><b>\w</b></td><td>буквы и цифры, знак подчёрк [a-zA-Z0-9] (\w+ выберет слова)</td></tr>
  <tr><td><b>\W</b></td><td>не буквы и цифры [^а-яА-Я0-9Ёё]</td></tr>
  <tr><td>  </td></tr>
  <tr><td><b>|</b></td><td>или</td></tr>
  <tr><td><b>\b</b></td><td>граница слова</td></tr>
  <tr><td><b>^</b></td><td>отрицание для символьного класса или начало строки</td></tr>
  <tr><td><b>$</b></td><td>конец строки</td></tr>
  <tr><td><b>\A</b></td><td>начало текста</td></tr>
  <tr><td><b>\B</b></td><td>отсутствие границы слова</td></tr>
  <tr><td><b>\Z</b></td><td>конец текста</td></tr>
  <tr><td><b>(?:exp)</b></td><td>не сохраняющие скобки</td></tr>
  <tr><td><b>(?=exp)</b></td><td>проверка на совпадение</td></tr>
  <tr><td><b>(?!exp)</b></td><td> проверка на несовпадение</td></tr>
  <tr><td><b>(?&lt;=exp)</b></td><td>проверка на совпадение ретроспективная</td></tr>
  <tr><td><b>(?&lt;!exp)</b></td><td> проверка на несовпадение ретроспективная</td></tr>
</table><br>

match = re.findall(r"^&lt;script.*?>([\w\W]+)(?=&lt;/script>)", text, re.MULTILINE) - взять содержимое тега script (без самого script); [\w\W] - что бы вошёл символ переноса строки<br><br>

match = re.findall(r"([-\w]+)[ \t]*=[ \t]*[\" ']([^\" ']+)(?&lt;![ \t])", text, re.MULTILINE) - пары ключ, значение; ключ - символы, дефис; пробел или табуляция; равно; пробел или табуляция; ковычки; содержимое значения(до не кавычки); ретроспективная проверка на наличие пробела или табуляции (не вкл)<br><br>

<i>Квантификаторы</i><br>
 {m} - повторений; {mix,max}; {min,}; {,max}!<br>
 жадные(мажорные, greedy) - по максимуму, нежадные(минорные, non-greedy) {2,5}? <br>
 <b>?</b> - {0,1} re.findall(r"стеклянн?ый")<br>
 <b>*</b> - {0,}<br>
 <b>+</b> - {1,}<br><br>

 text = &lt;p> Pic &lt;img='bg.jpg'> in text&lt;/p> <br>
 match = re.findall(r"&lt;img.*?>", text) - нежадный поиск (до первой скобки)<br>
 match = re.findall(r"&lt;img[^>]*>", text) - то же<br><br>

 text = "lat=5, lon=3"<br>
 match = re.findall(r"(?:lat|lon)\s*=\s*(\d+)) - или lat или lon в несохраняющих скобках .. ['lat=5', 'lon=3']<br>
 match = re.findall(r"(lat|lon)\s*=\s*(\d+)") - сохраняющие скобки ..[('lat', '5'), ('lon', '3')]<br><br>

 (?P<name>...) (?P=name) именованые сохраняющие скобки<br>

 <b>flags:</b><br>
 <i>re.A (re.ASCII)</i><br>
 <i>re.I (re.IGNORCASE)</i> - без учёта реистра символов.(case-insensitive)<br>
 <i>re.M (re.MULTILINE)</i> - влияет на проверки ^, $(с начала строки)<br>
 <i>re.S (re.DOTALL)</i> - ищет по всему тексту<br>
 <i>re.X (re.VERBOSE)</i> - позволяет вкл коментарии. <br>
 <i>re.DEBUG</i> - режим отладки.<br><br>

 Флаги можно комбинировать с помощью пайп (pipe) "|"<br>
 match = re.findall(r"(?im)python", text) - включить флаги в шаблон<br><br>

 <p><a href="https://habr.com/ru/articles/349860/" target="_blank" rel="noopener" >ShashkovS</a> - регулярные выражения</p>
 <p><a href="https://proproprogs.ru/modules/literaly-i-simvolnyy-klass" target="_blank" rel="noopener" >proproprogs</a> - регулярные выражения</p>
 <p><a href="https://docs.python.org/3/library/re.html" target="_blank" rel="noopener" >The Python Tutorial</a> - Python 3.11.4 documentation</p>
 <p><a href=" https://www.regular-expressions.info/" target="_blank" rel="noopener" >regular-expressions</a> - подробный материал</p>
  </section>

  <section id="s8">
    <b>import pandas as pd</b><br>
  </section>

  <section id="s9">
    <b>from pathlib import Path</b><br>
<i>p = Path("C:/Users/Al/spam.txt")</i><br>
Path.cwd() - текущая рабочая папка (current working directory)<br>
Path('spam', 'bacon', 'eggs') ..WindowsPath('spam/bacon/eggs') - объект<br>
str(Path(r'E:/spam') / 'bacon' / 'eggs') .. 'E:\\spam\\bacon\\eggs'<br>
if not p.exist():<br>
&nbsp;&nbsp;&nbsp;&nbsp; Path(r"E:/waffles").mkdir() - создать папку, если такой нет<br><br>

p.anchor .."C:\\"<br>
p.parent ..WindowsPath(("C:/Users/Al")) - объект<br>
p.name .. 'spam.txt'<br>
p.stem .. 'spam'<br>
p.suffix .. 'txt'<br>
p.drive .. 'C:'<br><br>

p.patent - path<br>
p.parents[0] - вернёт путь в виде path<br>
p.parents[1] - часть пути на звено меньше<br><br>

list(p.glob('*')) - список из генератора всех файлов папки<br>
('*.txt') - список файлов с расширением .txt<br>
('*.?x?') - ? заменяет еденичный символ<br><br>

for file in list(p.glob('*.py')):<br>
&nbsp;&nbsp;&nbsp;&nbsp; print(file) - файлы с расширением .py<br><br>

p.exists() - Этот файл существует?<br>
p.is_file() - Это файл?<br>
p.is_dir() - Это папка?<br><br>

g = Path(r"G:/"); g.exists() .. False - флэшка не вставлена<br><br>

p = p / 'hello.txt' - сохранили в p путь до текстового файла (или создали его)<br>
p.write_text('Hello') - записали в файл слово; вернёт кол-во знаков<br>
p.read_text() .. 'Hello'<br><br>


  </section>

  <section id="s10">
    <b>import os</b><br>
os.chdir(r"E:/My Documens/книги/my_py") - сделать рабочей указаную папку.<br>
os.mkdir() - создать папку(ошибка, если уже существует)<br>
os.rmdir() - удалить папку (пустую)<br>
os.rename(source, target) - переименовать файл (путь мб абс или относ)<br>
os.makedirs(r"E:/waffles/valnut") - создать папки рекурсивно<br>
os.remove(path) - удалить путь к файлу<br>
os.path.abspath(path) - способ конвертировать относительный путь  в абсолютный<br>
os.path.isabs(path) - это абсолютный путь?<br>
os.path.exists(path) - существует?<br>
os.path.isdir(path) - это папка?<br>
os.path.isfile(path) - эо файл?<br>
os.path.relpath(path, start) - вернёт относительный путь от cwd или от указаного 'start'<br><br>

os.path.basename(r"E:/книги/spam.txt") .. spam.txt<br>
os.path.dirname(r"E:/книги/spam.txt") .. r"E:/книги"<br>
os.path.split(r"E:/книги/spam.txt") .. ("E:/книги", "spam.txt")<br>
(r"E:/книги/spam.txt").split(os.sep) .. ['E:', 'книги', 'spam.txt']<br><br>

os.listdir(path) - список файлов<br>
os.path.getsize(path) - размер файла в байтах (bytes)<br>
totalsize = 0<br>
for filename in os.listdir(path):<br>
&nbsp;&nbsp;&nbsp;&nbsp; totalsize += os.path.getsize(os.path.join(path, filename)) - список файлов в папке; с помощью <i>join</i> получаем абсолютный путь до файла<br><br>

os.path.join() - соединить путь и файл<br>

<i>os.unlink(path)</i> - удалить файл по указаному пути<br>
<i>os.rmdir(path)</i> - удалить папку по указаному пути<br>
<i>os.rmtree(path)</i> - удалить папку рекурсивно<br><br>

<i>os.walk(path)</i><br>
for folderName, subfolders, filenames in os.walk(path):<br>
&nbsp;&nbsp;&nbsp;&nbsp; print(f"current folder is {folderName}")<br>
&nbsp;&nbsp;&nbsp;&nbsp; for subfolder in subfolders:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; print(f"{folderName}:{subfolder})<br>
&nbsp;&nbsp;&nbsp;&nbsp; for filename in filenames:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; print(f"{folderName}:{filename})<br>
&nbsp;&nbsp;&nbsp;&nbsp; print()<br>

safe Deletes with the send2trash module.
  </section>

  <section id="s11">
    <b>import shutil</b><br>
<i>shutil.copy(source, destination)</i> - копирует файлы и папки; пути должны быть строками или Path obj; если в назначении определена только папка - название файла копируется; если папка и название файла - файл копируется с новым именем.<br><br>

<i>shutil.copytree(source, destination, ignore=None)</i> - копирует рекурсивно всё, что есть в папке.<br>
ignore=ignore_patterns('tmp*') - копировать всё кроме имён начинающихся с tmp<br>
<i>shutil.move(source, destenation)</i> - переместит файл или папку (в существующую папку)<br>
<i>shutil.rmtree(path, ignore_errors=False)</i> - удалит папку рекурсивно<br>
<i>shutil.make_archive(base_name, format[, root_dir[, bse_dir[, verbose[,dry_run[, oner[, group[, logger]]]]]]])</i> - имя архивного файла без расширения, расширение ('zip'), путь до папки, которую надо архивировать; архивированый файл будет создан в текущей директории<br>
<i>shutil.unpack_archive(filename[, extract_dir[, format[, filter]]])</i><br>
base_name - имя архива<br>
format - 'zip'<br>
root_dir - корневой каталог архива (откуда копировать)<br>

  </section>

  <section id="s12">
<b>import zipfile</b><br>
<i>archive file</i> - упакованый файл<br>
класс ZipFile(file, mode='r', compression=ZIP_STORED, allowZip64=True, compresslevel=None, strict_timestamps=True, metadata_encoding=None);<br>
Параметры: r, w, a - чтение, запись добавление.<br>
ZIP_STORED - без сжатия (по умолчанию)<br>
ZIP_DEFLATED - стандартный тип сжатия.<br>
методы: close(); getinfo(); namelist(); infolist(); open(); read(); extract(); extractall(); setpassword(); printdir()<br><br>

класс ZipInfo; атрибуты:<br>
filename - название файла<br>
date_time - последнее изменение файла (год, месяц, день, час, минута, секунда)<br>
compress_type - тип сжатия<br>
compress_size - размер после сжатия<br>
file_size - оригинальный размер файла<br>
is_dir() - это папка (else: это файл)<br><br>

with ZipFile("meta.zip", "r") as myzip:<br>
&nbsp;&nbsp;&nbsp;&nbsp; for item in myzip.infolist():<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; print(f"File Name: {item.filename} Date: {item.date_time} Size: {item.file_size}") - перечислит инфо для каждого файла<br><br>

exampleZip = zipfile.ZipFile('example.zip')<br>
dir(exampleZip) .. namelist, open, read...<br>
examleZip.namelist() - список спресованых файлов.<br>
fileInfo = exampleZip.getinfo(file) - инфо отдельного файла.<br>
fileInfo.file_size; fileInfo.compress_size; <br><br>

extractall(path, members=None, pwd=None)<br>
path - куда извлекать (по умолчанию в cwd; можно 'files' - создали папку для извлечения)<br>
members - список названий файлов, которые надо извлечь<br>
pwd - пароль, если архив запоролен<br>
myzip.extract('hello.txt') - извлечь один файл<br>
content = mysip.read('hello.txt')<br>

newZip = zipfile.ZipFile('new.zip', 'w') - открыть ZipFile object в режиме записи или добавления 'a'.<br>
newZip.write('spam.txt', compress_type=zipfile.ZIP_DEFLATED)<br>
newZip.close()<br><br>

with ZipFile('spam.zip', 'w') as myzyp: - менеджер контекста<br>
&nbsp;&nbsp;&nbsp;&nbsp; pass - пустой zipfile создан и закрыт. <br><br>

При записи первый параметр - записываемый файл, второй - имя внутри архива (если добавляем файл с уже имеющимся именем); ZIP_DEFLATED надо импортировать из zipfile<br>
with ZipFile('new.zip', 'a', compression=ZIP_DEFLATED, compresslevel=3) as myzip:<br>
&nbsp;&nbsp;&nbsp;&nbsp;myzip.write('hello.txt', 'hello1.txt')<br>
&nbsp;&nbsp;&nbsp;&nbsp;myzip.write('forest.jpg')<br>
  </section>

  <section id="s13">
    <b>import shelve</b><br>
сохранить как бинарные файлы; появятся три файла с расширениями <i>.bak, .dat, .dir</i>;<br>
open(path[, flag='c'[, protocol=None[, writeback=False]]])<br>
<i>c</i> (по умолчанию) - чтение и запись<br>
<i>r; w</i> - только для чтения или записи<br>
<i>n</i> - для записи создаётся или перезаписывается<br><br>

shelfFile = shelf.open('mydata') - принемает строку (не Path obj)<br>
cats = ['Zophie', 'Poork', 'Simon']<br>
shelfFile['cats'] = cats - сохранить как словарь по ключу<br>
shelfFile.close()<br><br>

shelfFile = shelf.open('mydata') <br>
shelfFile['cats'] .. ['Zophie', 'Poork', 'Simon']<br>
list(shelfFile.keys()) .. ['cats']<br>
list(shefFile.values()) .. [['Zophie', 'Poork', 'Simon']]<br>
shelfFile.close()<br><br>

with shelve.open('mydata') as shelve_f:<br>
&nbsp;&nbsp;&nbsp;&nbsp;if 'cats' in shelve_f:
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; print(cats = shelve_f['cats'])<br><br>

для перебора всех ключей используем цикл.<br>
метод keys() - верёт все ключи; метод values() - все значения; items() - набор кортежей<br>
pop(key, value) - удалит и вернёт ключ и значение по умолчанию (если ключ на найден)<br>
del shelve_f['key'] - удалить<br>
shelve_f.clear() - удалить всё<br>
  </section>

  <section id="s14">
    <b>import pprint</b><br>
  </section>

  <section id="s15">
    <b>import csv</b><br>
список списков; запись в файл 'w' или добавление'a'; третий параметр позволяет коректно считывать в разл. операц. системах; методы writerows and writerow<br>
with open('users.csv', 'w', newline='', encoding='utf8') as file:<br>
&nbsp;&nbsp;&nbsp;&nbsp; writer = csv.writer(file)<br>
&nbsp;&nbsp;&nbsp;&nbsp; writer.writeros(list_of_users)<br><br>

для чтения объект reader<br>
with open('users.csv', 'r', newline='') as file:<br>
&nbsp;&nbsp;&nbsp;&nbsp; reader = csv.reader(file)<br>
&nbsp;&nbsp;&nbsp;&nbsp; for row in reader:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; print(row[1], '-', row[2])<br><br>

список словарей; каждая трока - словарь; отдельно список заголовков;<br>
writer = csv.DictWriter(file, fieldnames=column)<br>
writer.writeheader()<br>
writer.writerows(users)<br>
writer.writerow(user)<br><br>

with open('users.csv', 'r', newline='') as file:<br>
&nbsp;&nbsp;&nbsp;&nbsp;reader = cssv.DictReader(file)<br>
&nbsp;&nbsp;&nbsp;&nbsp;for row in reader:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;print(row['name'], ' - ', row['age'])
  </section>

  <section id="s16">
    <b>import pickle</b><br>
к режиму записи или чтения добавляем <i>'b'</i> ("wb", "rb")<br>
<i>dump(obj, file)</i> - записывавет объект в бинарный файл.<br>
<i>load(file)</i> - считывает данные из бинарного файла в объект.<br><br>

name = "Tom"; age = "19"<br>
with open("user.dat", "wb") as file:<br>
&nbsp;&nbsp;&nbsp;&nbsp; pickle.dump(namee, file)<br>
&nbsp;&nbsp;&nbsp;&nbsp; pickle.dump(age, file)<br><br>

with open("user.dat", "rb") as file:<br>
&nbsp;&nbsp;&nbsp;&nbsp; name = pickle.load(file)<br>
&nbsp;&nbsp;&nbsp;&nbsp; age = pickle.load(file)<br>
&nbsp;&nbsp;&nbsp;&nbsp; print('Name: ', name, 'Age: ', age)<br><br>

users = [['Tom', 34, True], ['Alice', 23, False]]<br>
with open('users.dat', 'wb') as file:<br>
&nbsp;&nbsp;&nbsp;&nbsp; pickle.dump(users, file)<br><br>

with open('users', 'rb') as file:<br>
&nbsp;&nbsp;&nbsp;&nbsp; usersF = pickle.load(file)<br>
&nbsp;&nbsp;&nbsp;&nbsp; for user in usersF:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; print(f"Name {user[0]}, age: {user[1]}, married: {user[2]})<br>
  </section>

  <h3 align="center">Сторонние модули:</h3> 

  <section id="s50">   
pip install pyperclip<br>
<b>import pyperclip</b><br>
pyperclip.copy('Hello, world')<br>
pyperclip.paste()<br>
  </section>

  <section id="s51">
pip install requests<br>
<b>import requests</b><br>
url = "https:\.."<br>
r = requests.get(url)<br>
r.encoding<br>
r.text<br>
r.json()<br>
  </section>

  <section id="s52">
pip install bs4<br>
<b>from bs4 import BeautifulSoup as bs</b><br>
soup = BeautifulSoup(r.text, 'html')<br>
soup.find('div', class_="class_name").find('a', "class_name")<br>
  </section>

  <section id="s53">
pip install selenium<br>
<b>import selenium</b><br>
  </section>

  <section id="s54">
pip install pyinputplus<br>
<b>import pyinputplus as pyip</b><br>
<i>inputStr()</i><br>
<i>inputNum()</i> min=None, greaterThan=None, lessThan=None<br>
<i>inputChoice()</i><br>
<i>inputMenu()</i><br>
<i>inputDatetime()</i><br>
<i>inputYesNo()</i><br>
<i>inputBool()</i><br>
<i>inputEmail()</i><br>
<i>inputFilepath()</i><br>
<i>inputPassword()</i><br>
  </section>

  <section id="s55">
pip install --user lxml<br>
используется вместо <i>'html.parser'</i>  (встроенного в Python) <br>
  </section>

  <section id="s56">
pip install pywin32; import win32api<br>
модуль для работы с windows<br><br>

pip install py32printing; import win32print<br>
вывод на принтер через windows<br>
  </section>

  <section id="s57">
<i>pip install send2trash</i><br>
<b>import send2trash</b><br>
send2trash.send2trash(path)<br>
  </section>

  <section id="s58">
<i>pip install pprint</i><br>
<b>import pprint</b><br>
<i>pprint.pprint</i> - печать списков<br>
<i>pprint.pformat</i> - вернёт текст в виде строки<br><br>

with open('myCats.py', 'w') as file:<br>
&nbsp;&nbsp;&nbsp;&nbsp;file.write('cats = ' + pprint.pformat(cats) + '\n' ) # записали в файл с расширением .py список словарей <br>
теперь можно вызвать import myCats; myCats.cats - вернёт список; к папке с файлом должен быть путь в 'переменных среды'<br>
  </section>

  <section id="s59">
pip install openpyxl<br>
<b>import openpyxl</b><br>

pass
  </section>

            </aside>
        </div>

      <footer><h3 id="s99">Ссылки:</h3>
<p><a href="https://docs.python.org/3/tutorial/introduction.html" target="_blank" rel="noopener" >The Python Tutorial</a> - Python 3.11.4 documentation</p>
<p><a href="http://automatetheboringstuff.com/2e/chapter1/" target="_blank" rel="noopener" >automatetheboringsruff</a> - AlSweigart</p>
<p><a href="https://pythex.org/" target="_blank" rel="noopener" >pythex</a> - regex</p>
      </footer>
    </div>  
</body>
</html>