<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="../css/style1.css" />
    <title>libraryPy</title>
</head>
<body>
  <div class="cont">
    <nav class="menu">
      <ul class="menu_list">
        <li><a href="../index.html"><img src="../img/icon-home.png" alt="home"></a></li>
        <li>
          <span>Python</span>
          <ul class="sub_menu_list">
            <li><a href="./startPy.html">startPy</a></li>
            <li><a href="./libraryPy.html">libraryPy</a></li>
            <li><a href="./dir_and_file.html">Папки и файлы</a></li>
            <li><a href="./pictures.html">Картинки и графики</a></li>
            <li><a href="./web_scraping.html">Web scraping</a></li>
            <li><a href="./flask.html">Flask</a></li>
            <li><a href="./django.html">Django</a></li>
            <li>Искуственный интелект</li>
          </ul>
        </li>
        <li>
          <span>Frontend</span>
          <ul class="sub_menu_list">
            <li><a href="../frontend/html.html">HTML</a></li>
            <li><a href="../frontend/css.html">CSS</a></li>
            <li><a href="../frontend/js.html">JavaScript</a></li>
            <li><a href="../frontend/jsDom.html">JavaScript DOM</a></li>
          </ul>
        </li>
        <li>
          <span>Books</span>
          <ul class="sub_menu_list">
            <li><a href="../books/english.html">Books in English</a></li>
            <li><a href="../subjects/math.html">Математика</a></li>
            <li><a href="../subjects/environment.html">Окружение</a></li>
            <li><a href="">Справочники</a></li>
          </ul>
        </li>
      </ul>
    </nav>
    <div class="left_right">
      <aside class="left">
  
    <p><a href="#s1">random</a></p>
    <p><a href="#s2">sys</a></p>
    <p><a href="#s3">copy</a></p>
    <p><a href="#s4">pyperclip</a></p>
    <p><a href="#s5">math</a></p>
    <p><a href="#s6">shelve</a></p>
    <p><a href="#s7">pickle</a></p>
    <p><a href="#s8">pprint</a></p>
    <p><a href="#s9">pyinputplus</a></p>
    <p><a href="#s10">Время</a></p>
    <p><a href="#s11">Regex</a></p>
    <p><a href="#s12">Pandas</a></p>
    <p><a href="#s13">NumPy</a></p>
    <p><a href="#s14">TeX</a></p>
    <p><a href="#s15">pywin32</a></p>
    <p><a href="#s16">threading</a></p>
    <p><a href="#s17">geocoder</a></p>
    <p><a href="#s18">SQLite</a></p>
      </aside>
    
      <aside class="right"><h1 align="center" id="s0">Library for Python.</h1>

  <section id="s1"> <b>import random</b><br>

<i>random.randint(a, b)</i> - случайное число от a до b, включая оба<br>
<i>random.choise([list])</i> - слуачайное значение из списка<br>
<i>random.choice(list(range(20)))</i> - случайное из 20<br>
<i>random.shuffle(list)</i> - перемешать список (на месте)<br>
<i>a = random.sample(list, 3)</i> - вернёт список из трёх рандомных значений<br>
<i>random.random()</i> - от 0 до 1<br>
<i>random.uniform(0,5)</i> - тоже с заданым диапазоном<br>
<i>random.seed(123)</i> - указать произвольное число и случайная последовательность будет повторяться.<br><br>

numbers = [random.randint(-10,10) for i in range(20)]
  </section>  

  <section id="s2"> <b>import sys</b><br>

<i>sys.exit()</i> (Try, except; Ctrl+c - выход без выброса ошибки)<br>
  </section>

  <section id="s3"> <b>import copy</b><br>

копирование объектов<br>
<i>copy.copy(test)</i> - поверхносная копия<br>
<i>copy.deepcopy(test)</i> - глубокое копирование<br>
  </section>

  
  <section id="s4"> <i>pip install pyperclip;</i> <b>import pyperclip</b><br>

pyperclip.copy('Hello, world')<br>
pyperclip.paste()<br>
  </section>

  <section id="s5"> <b>import math</b><br>

math.pi<br>
math.ceil(5.2) .. 6<br>
math.floor(5.99) .. 5<br>
.sqrt(); .sin(); .cos();<br>
  </section>


  <section id="s6"> <b>import shelve</b><br>

сохранить как бинарные файлы; появятся три файла с расширениями <i>.bak, .dat, .dir</i>;<br>
open(path[, flag='c'[, protocol=None[, writeback=False]]])<br>
<i>c</i> (по умолчанию) - чтение и запись<br>
<i>r; w</i> - только для чтения или записи<br>
<i>n</i> - для записи создаётся или перезаписывается<br><br>

shelfFile = shelf.open('mydata') - принемает строку (не Path obj)<br>
cats = ['Zophie', 'Poork', 'Simon']<br>
shelfFile['cats'] = cats - сохранить как словарь по ключу<br>
shelfFile.close()<br><br>

shelfFile = shelf.open('mydata') <br>
shelfFile['cats'] .. ['Zophie', 'Poork', 'Simon']<br>
list(shelfFile.keys()) .. ['cats']<br>
list(shefFile.values()) .. [['Zophie', 'Poork', 'Simon']]<br>
shelfFile.close()<br><br>

with shelve.open('mydata') as shelve_f:<br>
&nbsp;&nbsp;&nbsp;&nbsp;if 'cats' in shelve_f:
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; print(cats = shelve_f['cats'])<br><br>

для перебора всех ключей используем цикл.<br>
метод keys() - верёт все ключи; метод values() - все значения; items() - набор кортежей<br>
pop(key, value) - удалит и вернёт ключ и значение по умолчанию (если ключ на найден)<br>
del shelve_f['key'] - удалить<br>
shelve_f.clear() - удалить всё<br>
  </section>

  <section id="s7"> <b>import pickle</b><br>

к режиму записи или чтения добавляем <i>'b'</i> ("wb", "rb")<br>
<i>dump(obj, file)</i> - записывавет объект в бинарный файл.<br>
<i>load(file)</i> - считывает данные из бинарного файла в объект.<br><br>

name = "Tom"; age = "19"<br>
with open("user.dat", "wb") as file:<br>
&nbsp;&nbsp;&nbsp;&nbsp; pickle.dump(name, file)<br>
&nbsp;&nbsp;&nbsp;&nbsp; pickle.dump(age, file)<br><br>

with open("user.dat", "rb") as file:<br>
&nbsp;&nbsp;&nbsp;&nbsp; name = pickle.load(file)<br>
&nbsp;&nbsp;&nbsp;&nbsp; age = pickle.load(file)<br>
&nbsp;&nbsp;&nbsp;&nbsp; print('Name: ', name, 'Age: ', age)<br><br>

users = [['Tom', 34, True], ['Alice', 23, False]]<br>
with open('users.dat', 'wb') as file:<br>
&nbsp;&nbsp;&nbsp;&nbsp; pickle.dump(users, file)<br><br>

with open('users', 'rb') as file:<br>
&nbsp;&nbsp;&nbsp;&nbsp; usersF = pickle.load(file)<br>
&nbsp;&nbsp;&nbsp;&nbsp; for user in usersF:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; print(f"Name {user[0]}, age: {user[1]}, married: {user[2]})<br>
    </section>

  <section id="s8"> <i>pip install pprint</i>; <b>import pprint</b><br><br>
<i>pprint.pprint</i> - печать списков<br>
<i>pprint.pformat</i> - вернёт текст в виде строки<br><br>

with open('myCats.py', 'w') as file:<br>
&nbsp;&nbsp;&nbsp;&nbsp;file.write('cats = ' + pprint.pformat(cats) + '\n' ) # записали в файл с расширением .py список словарей <br>
теперь можно вызвать import myCats; myCats.cats - вернёт список; к папке с файлом должен быть путь в 'переменных среды'<br>
  </section>

  <section id="s9"> <i>pip install pyinputplus</i><br>
<b>import pyinputplus as pyip</b><br><br>

<i>inputStr()</i><br>
<i>inputNum()</i> min=None, greaterThan=None, lessThan=None<br>
<i>inputChoice()</i><br>
<i>inputMenu()</i><br>
<i>inputDatetime()</i><br>
<i>inputYesNo()</i><br>
<i>inputBool()</i><br>
<i>inputEmail()</i><br>
<i>inputFilepath()</i><br>
<i>inputPassword()</i><br>
  </section>

  <section id="s10"><h3 align="center">Время</h3>

UTC - Coordinated Universal Time<br>
EST, EDT - восточное, западное побережье Америки.<br>
Unix epoch - начало эпохи (1970, 1, 1, 12, 0, 0)<br><br>

<b>import time</b><br>
t = <i>time.time()</i> - без аргумента; привязана к системным часам; время в секундах с начала эпохи(1970-01-01 0:00:00 utc)<br>
Дальше можно подставлять аргумент (секунды)<br>
<i>time.gmtime()</i> ..time.struct_time(tm_year=2023, tm_mon=10, tm_mday=6, tm_hour=13, tm_min=28, tm_sec=59, tm_wday=4, tm_yday=279, tm_isdst=0)<br>
<i>time.localtime()</i> ..time.struct_time(tm_year=2023, tm_mon=10, tm_mday=6, tm_hour=16, tm_min=29, tm_sec=13, tm_wday=4, tm_yday=279, tm_isdst=0)<br>
<i>time.ctime()</i> - Thu Aug 31 15:52:18 2023<br>
local = dt.datetime.fromtimestamp(t)<br>
zone = dt.timezone(dt.timedelta(seconds=abs(time.timezone))) ..10800сек (3часа)<br>
local = dt.datetime.fromtimestamp(t, zone) ..2023-10-06 17:00:48.587647+03:00<br>
<i>time.sleep(1)</i> - задержка 1с<br><br>

start_time = <i>time.monotonic()</i> - замеряем время от start_time.<br>
print(f"Прошло {time.monotonic() -  start_time}")<br><br>

time.strftime([format]) - текущее время в указаном формате.<br><br>

<b>import datetime as dt</b><br>
Классы: date, time, datetime<br>
<i>.date</i><br>
date(year, month, day)<br>
print(dt.date(2023,8,31)) .. 2023-08-31 (изоформат)<br>
today = dt.date.today() .. 2023-08-31<br>
print(f"{today.day}.{today.manth}.{today.year}") .. 31.8.2023<br><br>

today.replace(day=20) - изменит только в новой переменной.<br><br>

<i>.time</i><br>
time([hour][, min][, sec][, microsec]) (без параметров 0:0:0)<br>
print(dt.time(10,47,20)) .. 10:47:20<br><br>

<i>.datetime</i><br>
datetime(year, month, day [, hour][, min][, sec][, microsec])<br>
print(dt.datetime(2023,8,31)) .. 2023-08-31 00:00:00<br>
now = dt.datetime.now()<br> ..2023-08-31 10:58:03.968252<br>
now.date; now.month; now.year; now.hour, now.minute, now.microsecond, now.day_name<br>
ts = dt.datetime.timestamp(now) ..1696590800.965508<br>
dt.datetime.fromtimestamp(ts).date() .. 2023-10-06<br><br>

<i>strptime(str, format)</i> - распарсить строку; преобразовать в дату<br>
%d; %m; %y; %Y; %H; %M; %S - день; номер месяца; год (две цифры); год (4 цифры); час; минута; секунда<br>
deadline = dt.datetime.strptime("05-22-2017 12:30", "%m-%d-%Y %H:%M")<br>
print(deadline) .. 2017-05-22 12:30:00<br>
print(deadline.date()) ..2017-05-22<br><br>

<i>strftime(format)</i> - для объектов <i>date</i> и <i>time</i>; принимает один параметр - формат<br>
%a - Wed; %A - Wednesday; %b - Oct; %B - October<br>
%d - 01(день); %m - 05(месяц); %y - 23; %Y - 2023<br>
%H - 13(часов); %I - 01(час); %M; %S; %f - микросекунда<br>
%p - AM/PM; %c - дата и время местный формат<br>
%x; %X - дата; время - местный формат<br>
print(now.strftime("%d %b (%A)")) .. 31 Aug (Thursday)<br><br>

<i>import locale</i><br>
<i>locale.setlocale(locale.LC_ALL, "")</i> - для использования русских(местных) слов<br><br>

<i>dt.timedelta([days][, seconds][, microseconds][, milliseconds][, minutes][, hours][, weeks])</i> - класс;<br>
now + dt.timedelta(days=100) .. плюс сто дней от now<br><br>

three_hours = dt.timedelta(hours=3, minutes=25) .. 3:25:00<br>
two_days = dt.timedelta(2, 25) .. 2 days, 0:00:25<br>
delta = three_hours + two_days .. 2 days, 3:25:25<br><br>

методы: <i>days, seconds, microseconds, total_seconds()</i><br>
delta.seconds; delta.total_seconds()<br><br>

if now > deadline:<br>
&nbsp;&nbsp;&nbsp;&nbsp;print("Time is over")<br>
elif now.day == deadline.day and now.month == deadline.month:<br>
&nbsp;&nbsp;&nbsp;&nbsp;print("today")<br>
else:
&nbsp;&nbsp;&nbsp;&nbsp;period = deadline - now<br>
&nbsp;&nbsp;&nbsp;&nbsp;print(f"осталось {period.days} дней")<br>
  </section>

  <section id="s11"><h3 align="center">Regex</h3>

<p><a href="https://habr.com/ru/articles/349860/" target="_blank" rel="noopener" >ShashkovS</a> - регулярные выражения<br>
<a href="https://proproprogs.ru/modules/literaly-i-simvolnyy-klass" target="_blank" rel="noopener" >proproprogs</a> - регулярные выражения<br>
<a href="https://docs.python.org/3/library/re.html" target="_blank" rel="noopener" >The Python Tutorial</a> - Python 3.11.4 documentation<br>
<a href=" https://www.regular-expressions.info/" target="_blank" rel="noopener" >regular-expressions</a> - подробный материал<br>
<a href="https://regex101.com/" target="_blank" rel="noopener" >regex101</a> - тренеровка</p>
<b>import re</b> - Regular expressions (regexes)<br><br>

Специальные символы: \ . $ ? + * {} [] () | - надо экранировать (\) <br>
Символьные классы [а-яА-ЯёЁ0-9], в них спец символы не работают (кроме '\')<br><br>
<table>
  <tr><td><b>.</b></td><td>любой символ; кроме \n; с флагом re.DOTALL - весь текст (wildcard)</td></tr>
  <tr><td><b>\d</b></td><td>любая цифра [0-9]</td></tr>
  <tr><td><b>\D</b></td><td>любой не цифровой символ [^0-9]</td></tr>
  <tr><td><b>\s</b></td><td>любой пробельный символ [\t\n\r\f\v]</td></tr>
  <tr><td><b>\S</b></td><td>любой непробельный символ</td></tr>
  <tr><td><b>\w</b></td><td>буквы и цифры, знак подчёрк [a-zA-Z0-9] (\w+ выберет слова)</td></tr>
  <tr><td><b>\W</b></td><td>не буквы и цифры [^а-яА-Я0-9Ёё]</td></tr>
  <tr><td>  </td></tr>
  <tr><td><b>|</b></td><td>или</td></tr>
  <tr><td><b>\b</b></td><td>граница слова</td></tr>
  <tr><td><b>^</b></td><td>отрицание для символьного класса или начало строки</td></tr>
  <tr><td><b>$</b></td><td>конец строки</td></tr>
  <tr><td><b>\A</b></td><td>начало текста</td></tr>
  <tr><td><b>\B</b></td><td>отсутствие границы слова</td></tr>
  <tr><td><b>\Z</b></td><td>конец текста</td></tr>
  <tr><td><b>(?:exp)</b></td><td>не сохраняющие скобки</td></tr>
  <tr><td><b>(?=exp)</b></td><td>проверка на совпадение</td></tr>
  <tr><td><b>(?!exp)</b></td><td> проверка на несовпадение</td></tr>
  <tr><td><b>(?&lt;=exp)</b></td><td>проверка на совпадение ретроспективная</td></tr>
  <tr><td><b>(?&lt;!exp)</b></td><td> проверка на несовпадение ретроспективная</td></tr>
</table><br>

<i>match = re.findall(r"^&lt;script.*?>([\w\W]+)(?=&lt;/script>)", re.M)</i> - совпадение все знаки до проверки на совпадение (всё между тегами; если использовать .* - не попадёт \n)<br>
<i>(?&lt;=&lt;script>)</i> - захватит и закрывающий тег<br>
<i>match = re.findall(r"([-\w]+)[ \t]*=[ \t]*[\" ']([^\" ']+)(?&lt;![ \t])", text, re.M)</i> - пары ключ, значение; ключ - символы, дефис; пробел или табуляция; равно; пробел или табуляция; ковычки; содержимое значения(до не кавычки); ретроспективная проверка на наличие пробела или табуляции (не вкл)<br><br>

<i>Квантификаторы</i><br>
{m} - повторений; {mix,max}; {min,}; {,max}<br>
по умолчанию - жадные(мажорные, greedy)<br>
со знаком '?' - нежадные(минорные, non-greedy) {2,5}? <br>
<b>?</b> - {0,1} re.findall(r"стеклянн?ый")<br>
<b>*</b> - {0,}<br>
<b>+</b> - {1,}<br><br>

text = "author=Pushkin; title=Onegin; price=200"<br>
match = re.findall(r"\w+\s*=\s*[^;]+", text) - вывести список из 'ключ=значение' (все знаки пока не встретится ';')<br><br>

text = "&lt;p>Picture &lt;img alt='photo' src='bj.jpg'>in text&lt;/p>"<br>
match = re.findall(r"&lt;img.*?>", text) - вывести содержание тега img (нежадный поиск до первой угловой скобки)<br>
match = rt.findall(r"&lt;img\s*=\s*[^>]*?src\s*=\s*[^>]+>", text) - содержимое тега img, все знаки кроме '>' нежадный поиск до 'src', = и все знаки не '>' до угловой скобки<br><br>

text = "lat=5, lon=7, a=3"<br>
match = re.findall(r"(?:lat|lon)\s*=\s*\d+", text) - используем не сохраняющую скобку и '|' для вывода списка из ключ=значение только для lat and lon<br>
если использовать сохраняющую скобку вывод будет - ['lat', 'lon']<br>
если ещё и всё выражение взять в скобки - [('lat=5', 'lat'), ('lon=7', 'lon')]<br>
если сохр скобки для (lat|lon) и (\d+) - [('lat', '5'), ('lon', '7')]<br><br>

Сохраняющие скобки (при search, fullmatch and finditer) не изменяют вывод, но можно получить инфо по каждой группе (если не используется квантификатор; тогда только для последнего соответсвия); match.start(), match.end() <br><br>

Нумерация в группах: pattern = r"((\d)(\d))((\d)(\d))"<br>
0 - весь шаблон; 1 - первые две цифры; 2 - первая цифра; 3 - вторая; 4 - вторые две цифры; 5 - третья цифра; 6 - четвёртая; \1\2..<br><br>

можно дать имя сохр скобке (в угловых скобках) - (?P&lt;name>) и обращатся к ней (?P=name)<br>
Для search можно получить коллекцию именованных групп.<br>
<i>v = match.groupdict(); v['name']</i><br><br>

<b>search</b> <i>re.search(pattern, string, flags)</i> - находит первое совпадение или группы<br>
match = re.search(r"\s*([А-Яа-яЁё]+)(\d+)\s*", r"--Опять45--")<br>
print(match[0], <i>match.start</i>(0), <i>match.end</i>(0)) - весь шаблон<br>
print(match[1], match.start(1), match.end(1)) - первая группа<br>
print(match.group(0,1,2,3)) - кортеж из групп 0 - всё совпадение; 1 - первая группа..<br>
<i>match.span(1)</i> - start, end первой группы<br>
<i>match.groups()</i> - кортеж из всех групп<br>
<i>match.lastindex</i> - индекс последней группы (кол-во групп)<br>
<i>match.groupdict()</i> - если группы именованые получим словарь название_группы: значение<br>
<i>match.expand(r"\g&lt;название_группы>:\2")</i> - вывод значения по названию группы или по номеру<br>
<i>match.re</i> - компелированный шаблон<br>
<i>match.string</i> - анализируемая строка<br><br>

<b>re.findinter()</b> - то же, что и search, только используется в цикле для нахождения всех совпадений.<br><br>

<b>re.findall()</b> - список совпадений или только кортежи из сохраняющих групп <br><br>

<b>re.match()</b> - совпадение от начала строки<br><br>

<b>re.fullmatch</b>(pattern, string) - проверить полное совпадение под шаблон <br><br>

<b>re.split</b>(pattern, string, maxsplit=0) - разделение по подстрокам, подходящим под шаблон; выбрать разделитель<br>
print(re.split(r"\W+", "Где скажите мне, мои очки?"))
... ["Где", "скажите", "мне", "мои", "очки"] - список без пробелов<br><br>

<b>re.sub</b>(pattern, repl, string, count=0, flags) - (substitution) заменить все непересекающиесся шаблоны на repl (строка или ф-ция)<br>
result2 = re.sub(r"old", r"new", txt) - заменить<br><br>

<b>re.subn</b> - тоже плюс кол-во замен<br><br>

pattern = <i>re.compile</i>(r'\d{3}') - шаблон передаём в  re.compile() и сохраняем в regex object<br>
result = <i>pattern.search</i>(txt).group()<br>
print(result[0] if result else 'NO')<br><br>

text = "Moscow Saint-Petersburg Novgorod"<br>
result2 = re.sub(r"\s*[\w-]+\s*", r"&lt;option>\1&lt;/option>\n", text)<br>
print(result2)<br><br>

count = 0<br>
def replFind(m): # аргумент - объект Match<br>
&nbsp;&nbsp;&nbsp;&nbsp; global count<br>
&nbsp;&nbsp;&nbsp;&nbsp; count += 1<br>
&nbsp;&nbsp;&nbsp;&nbsp; return f"&lt;option value='{count}'>{m.group(1)}&lt;/option>\n"<br>
result2 = re.sub(r"\s*[\w-]+\s*", replFind, text)<br>
.. &lt;option value='1'>Moscow&lt;option>...<br><br>

Использование групп при замене:<br>
Можно ссылаться на соответсвующую группу при помоощи \1, \2, ...(если групп больше 9, то \g<12>)<br>
print(re.sub(r"(\d\d)/(\d\d)/(\d{4})", r"\2.\1.\3", "03/25/2023")) - дата по амер; вернёт в нормальном порядке через точку<br><br>

 <b>flags:</b><br>
 <i>re.A (re.ASCII)</i> только латинские буквы, цифры и символ подчёркивания<br>
 <i>re.I (re.IGNORCASE)</i> - без учёта реистра символов.(case-insensitive)<br>
 <i>re.M (re.MULTILINE)</i> - влияет на проверки ^, $(с начала строки)<br>
 <i>re.S (re.DOTALL)</i> - ищет по всему тексту<br>
 <i>re.X (re.VERBOSE)</i> - позволяет вкл коментарии. <br>
 <i>re.DEBUG</i> - режим отладки.<br><br>

 Флаги можно комбинировать с помощью пайп (pipe) "|"<br>
 match = re.findall(r"(?aimsx)python", text) - включить флаги в шаблон
  </section>

  <section id="s12"><h3 align="center">Pandas</h3>
    <p><a href="https://pandas.pydata.org/docs/reference/index.html" target="_blank" rel="noopener" >pandas</a></p>
<i>pip insall pandas</i>; <b>import pandas as pd</b><br><br>

<b>Series</b><br>
mySeries = pd.Series(my_dict) - ключи будут индексами; можно обращатся по ключу (mySeries.Name)<br>
или mySeries.iloc[] - по цифровому индексу; в качестве индекса может быть срез или условие<br>
..type(mySeries) ..class 'pandas.core.series.Series'<br><br>

mySeries[mySeries > 100] - серия в которой  значения больше 100<br>
mySeries + 2 - ко всем значениям прибавить 2; так же другие операции<br>
sorted(mySeries) - список отсортированых значений (len, min, max, set, sum, product, mean, abs, head(), tail(), take([])) - могут использоватся как метод или аргумент<br>
.sort_values(inplace=False, ascending=False); после сортировки индексы будут не по порядку.<br>
.sort_index() - восстановить порядок индексов (также имена или даты)<br>
.index, .dype<br><br>

s = pd.Series(range(50)); s[3:40:3] - срез от 3 до 39 шаг 3(-3 обратный счёт)<br>
s.loc[[2,3]] - выбор двух строк; срез вкл оба знач; s.iloc[5:2:-1]<br>

<i>df = pd.DataFrame(data, columns=[list], index=[list])</i><br> 
..&lt;class 'pandas.core.frame.DataFrame'></class><br><br>

data - список списков, словарь, список словарей<br>
data = {'a':[list], 'b':[list]} ключи - назв.колонок, списки - значения(колонки)<br>
data = [['Alex', 10], ['Bob', 12], ['Clar', 13]]- список строк, две колонки(стр)<br>
data = [{dict1}, {dict2}] - каждый словарь - строка<br>
data = {'a':{'1': 'a1', '2': 'a2'}, 'b':{'1': 'b1', '2': 'b2'}} - словари со вложеными; a - назв.столбцов, '1'- индекс; 'a1' - значение<br>
df = pd.DataFrame([Series1, Series2]) - две строки в df<br><br>

один столбец представляется как Series; чтобы получить df надо применить к ней .reset_index() или подставить в конструктор pd.DataFrame(Series)<br><br>

<b>Прочитать, выгрузить в другой формат</b><br>
df = pd.read_csv(path, index_col='date', sep=';') - индексами сделать 'date'
   sep- разделитель, header=None, skiprow=[0,1,3], usecols=None,
   encoding='1251', na_values = ['NA', 'Missing'] (заменить значения на пустые)<br>
d_parser = lambda x: pd.datetime.strptime(x, '%Y-%m-%d %I-%p')<br>
df = pd.read_csv(path, parse_dates=['date'], date_parser=d_parser) - 'date' - Dtype - datetime64[ns]
    (index_col='date', parse_dates=True)<br>
df = pd.read_csv(path, usecols=[], nrows=100) - выбрать колонки и кол-во строк/вывода<br>
custom_datetime = lambda x: datetime.strptime(x, '%d%m%Y %H:%M:%S')<br>
df = pd.read_csv('тест2.csv', parse_dates=['date'], date_parser=custom_datetime)<br><br>

df = pd.read_excel(path, engine='odf', sheet_name='вещи', index_col='Дата')<br>
df.to_excel(path) - сохранить в таблице (один лист)<br>
для записи нескольких листов: writer = pd.ExcelWriter('table.ods', engine='odf', date_format=None, datetime_format=None, mode='w'('a'), storage_options=None, if_sheet_exists=None, engine_kwargs=None)<br>
df1.to_excel(writer, sheet_name='name1'); writer.save()<br><br>

with pd.ExcelWriter("my_table.ods", engine='odf') as writer:<br><br>

df = pd.read_sql_query(query, db)<br><br>

df.rename(index={'old': 'new'}, columns={'old': 'new'}, inplace=True)<br>
df.describe() - статистики по столбцам<br>
pd.options.mode.chained_assignment = None <br>
df.fillna(0, inplace=True) - заменим пропуски данных нулями<br><br>

col_names = [список новых заголовков]<br>
data = pd.read_csv(path, names=col_names, skiprows=[0]) - новые заголовки,
строку со старыми пропустить<br>
skiprows = [0,3,5] - пропустить указанные строки<br>
header= None, skiprows=[0] -  удалить заголовки<br><br>

Поменять в столбце "вид" название растений на цифры<br>
lablel_encode = {'вид': {'iris0': 0, 'iris1': 1, 'iris2': 2}}<br>
df1 = df.replace(label_encode)<br><br>

df['date'] = pd.to_datetime(df[date], format="%Y-%m-%d %I-%p", errors='ignore')<br>
df['date', 'start'] = df[['date', 'start']].apply(pd.to_datetime) - два столбца<br><br>

df.info() - кол-во строк(entries), индексы, название колонок, кол-во знач в них<br>
df.shape - кортеж (tupl) кол-во строк, кол-во колонок<br>
df.size - кол-во клеток в таблице<br>
df.T - transpose - меняет строки и столбцы местами<br>
df.dtypes - назв. колонок и тип данных в каждой<br>
df.values - список списков всех данных<br>
df.columns - список колонок<br>
df.index -  список индексов<br>
df.axes - список индексов и колонок<br>
df.head() - начало df<br>
df.tail() - конец df<br>
df.sample() - случайные строки<br><br>

df['reveneu'].nlargest(10) - 10 самых больших значений (Series).<br>
df.nlargest(10, 'revenue') - 10 строк (df).<br>
.nsmallest() - наименьшие.<br>

df.loc['name_str', 'name_column']<br>
df.loc[1] - первая строка Series<br>
df.loc[1:], df.loc[:5], df.loc[2:4], df.loc[[2,5], ['km', 'l']]<br>
df.loc[[5]] - строка по индексу DataFrame<br>
df.iloc[5], df.iloc[0,5] - по цифровому индексу [строка,колонка]<br>
df.loc[len(df)-1] - последняя строка Series<br>
df.loc[len(df)-1, ['data', 'note']] - посл. строка в двух колонках<br>
df.loc[:, 'name_column'] - весь сттолбец<br>
df.loc[:, ['name1', 'name2']] - два столбца<br>
df.loc[:, 'name1':'name2'] - несколько столбцов подряд<br>
df.iloc[[1,3]] - первая и третья строка<br><br>

df['name_columns'], df.name_columns - колонка Series<br>
df[2:4] - сокращённое две строки df<br><br>

<b>Индексы</b><br>
df.reset_index(inplace=True) - индексы стали первым столбцом<br>
df.reset_index(drop=True, inplace=True)- переустановить индексы<br>
df.set_index('month', inplace=True) - столбец 'month' стал индексами<br>
df = pd.read_csv(path, index_col='month') - прочитать csv 'month' - индексы<br>
df.to_csv(path, index_label='month') - сохран. в csv столбец индексов с именем<br>
df.svechi.dropna().index - список индексов соотв. не пустым знач. в 'svechi'<br>
df.svechi.dropna().index [-1] -  последний индекс в списке<br>
df.index[df.svechi == 206795]  - индекс значения 206795<br>
df.sort_index()<br>
df.rename(index={'old': 'new'}, inplace=True)<br>
df.index = [список новых индексов]<br>
df.index.names = ['month'] - переименовали колонку с индексами<br><br>

<b>Столбец</b><br>
df = pd.read_csv(path, names=[list], skiprows=[0])- поменяли заголовки,
     оригинальные пропустили<br>
df['name_column'] - столбец в Series (df.name_column)<br>
df[['name1', 'name2']] - несколько столбцов<br>
df.astype({'name_column': 'int'}) - преобразовать тип данных в столбце<br>
df.name.dropna() - вызвать стобец 'name' без пустых значений<br>
subset =[] -  аргумент в котором указываются столбцы в которых искать<br>
df.rename(columns={'name1': 'new_name1'}, inplace=True) - переименовать<br>
df = df[['b', 'c', 'a', 'd']] - поменять порядок столбцов<br>
df.columns = ['name1', name2...nameN] - переименовать список столбцов<br>
df['new_name'] = [1,2,3] - новый столбец и значения соответсвуют кол. строк<br>
    одно значение  - повторится во всех строках<br>
df.insert(2, 'Team', [list values]) - (индекс колонки перед которой вставляем,
    название, данные)<br><br>

df.date = pd.DatetimeIndex(df.date) - столбец date - формат времени<br>
df.age = df['age'].astype(float) - пустые знач только в float<br>
df = df.astype({'price': 'int', 'usdprice': 'float'})<br>
del df['name_column']                                   - удалить столбец<br>
df.drop(['name_column'], axsis=1, inplace=True)         - удалить столбец<br>
df = df.drop(['name1_column', 'name2_column'], axis=1)  - удалить столбец<br>
df.pop('name_column')                                   - удалить столбец<br>
df.groupby('Cluster').mean() - сгрупировали по столбцу Cluster и посчитали
  среднее значение<br>
df.loc[df.Name == 'Bob'] - все строки с именем Bob<br>
df.loc[df.Name == 'Bob', 'Name'] = 'Kat' - в столбце Name заменили имя<br>
<i>and</i> - <b>&</b>; <i>or</i> - <b>|</b>; <i>not</i> - <b>~</b><br><br>

room3 = df.room3<br>
room3.loc[room3 > 100] - в столбце room3 значения больше 100<br><br>

df.names.unique() - уникальные значения в столбце names<br>
df.names.value_counts() - кол-во разных значений; аргумент [normalize=True] - в долях от общего кол-ва.<br>
.isnull() - возвращает булевое знач<br>
.sum() - суммирует<br>
df.room.isnull().sum() - кол-во пустых строк<br>
.fillna(0) - заменить пустые значения на указаное<br>
df.name = df['name'].fillna('unknown') - заменить значения в столбце<br>
.dropna(self, axis=0, how='any'(all - если все значения пропущены), thresh=None, subset=None(исключение для столбцов), inplace=False) - пропустить все пустые <br>
.duplicated()<br>
.drop_duplicates(inplace=True)<br>
.replace(name1, name2)<br>
df['room'].min(); df['room'].max()<br><br>

tenis.name = tenis.name.replace('Roger', 'Robert')<br>
label_encode = {'column_name': {'iris0': 0, 'iris1': 1}}<br>
df1 = df.replace(label_encode)<br>
df[name].count() - посчитать количество элементов<br>
df[name].value_counts() - посчитать кол-во каждого элемента<br>
x = iris.iloc[:,:-1].values - список списков - значения 4 из 5 столбцов<br><br>

<b>Строки</b><br>
df.loc['May'] = [list] - изменить/создать строку с индексом 'May'<br>
df.loc[len(df)]; df.iloc[-1] - последняя строка<br>
df.loc['name']  - строка с именем<br>
df.append({'A': 'bar', 'B': 4}, ignor_index=True)<br>
df.append(pd.Series(['bar', 4], index=['A', 'B'], ignor_index=True))<br>
df = df.drop(1, axis=0) - удалить первую строку<br>
df.drop('name_index',axis=0, inplace=True) - удалить строку<br>
df.drop(df.tail(1).index, inplace=True) - удалить последнюю строку<br><br>

line = pd.DataFrame({dict}, index=[3]) - вставить строку<br>
df2 = concat([df.iloc[:2], line, df.liloc[3:]].reset_index(drop=True))<br>

line = pd.DataFrame({dict}, index=[2,5])<br>
df2 = df.append(line, ignor_index=True)<br>
df2 = df2.sort_index().reset_index(drop=True)<br><br>

третий способ вставить строку<br><br>

<b>Сортировка</b><br>
df.sort_values(by='name_column, or list columns', ascending=False, inplace=False, <br>
kind='quicksort', no_position='last', ignore_index=False, key=None)
ascending - по возрастанию<br>
kind= [quicksort, mergesort, heapsort]<br>
key = любая ф-ция<br>
df.sort_values(by=['date', 'start'], ascending=[True, False], inplace=True)<br><br>
 
df = pd.concat([df1, dff2], ignore_index=True) - индексы(цифры) переустановить<br>
 
set_option<br>
pd.set_option('display.max_rows', None)<br>
pd.set_option('display.max_columns', None)<br>
pd.set_option('display.max_colwidth', None)<br><br>

<b>Время</b><br>
<i>NaT</i> - not a time; эквивалент NaN<br>
timestamp = pd.Timestamp("2023-03-25 15:30:00") - Timestamp('2023-03-25 15:30:00')<br>
timestamp.year; ().month; .day; .hour; .minute;  .weekday()
df.reset_index(inplace=True) - индексы в первую колонку<br>
df['date'] = pd.to_datetime(df['date'], dayfirst=True)<br>
df['date'] = pd.to_datetime(df['date'], format="%Y %B %d")<br>
df.sort_values(by='date', inplace=True)<br>
df.to_csv(path, index=False) - сохранить без столбца индексов<br>
df.set_index('date', inplace=True) - date индексы<br>
df.date['2021-01':'2021-02-25'] - срез по индексам (всё включено)<br>
avto.dayOfWeek = avto.date.dt.day_name() - новый столбец с днями недели<br>
.min(), .max()<br> 
avto.loc[avto.date>='2023'] - фрейм за 2023 год<br>
filt = (avto.date >= '2020') & (avto.date &lt; '2021')<br>
filt - (avto.date >= pd.to_datetime('2020-01-01'))<br>
highs = avto['revenue'].resample('m').max() - выборка по месяцам (список обозначений в документации)<br>
highs['2021-01-01'] - выбор по индексу.<br><br>

<b>Диапазон дат</b><br>
pd.date_range(start=datetime(year=2020, month=1, day=1), <br>
periods=30,
freq='D')   ...   DatetimeIndex(['2020-01-01', '2020-01-02', ... '2020-01-30'])<br>
date = pd.date_range('1/1/2022', periods=5, freq='H')<br>
DatetimeIndex(['2022-01-01 00:00:00', ...  '2022-01-01 05:00:00'])<br>

df = pd.concat([df1, df2], ignor_index=True) - восстановить порядок индексов<br><br>

<b>update</b>:<br>
обновит только существующие колонки или строки (лишнее игнорирует)<br>
df = pd.DataFrame(dict(A=[1,2,3], B=[4, 5, 6], C=[7, 8, 9]))<br>
new_column = pd.Series([40, 50], name='B', index=[0, 1])<br>
df.update(new_column) ... обновит стобец "В" два значения<br><br>

new_df = pd.DataFrame(dict(B=[40, 50]), index=[0,1])<br>
new_df = pd.DataFrame(dict(B=[40, 50, np.nan]))<br>
df.update(new_df) ... обновит стобец "В" два значения<br><br>

<b>Join</b><br>
DataFrame.join(self, other, on=None, how='left', \
                lsuffix='', rsuffix='', sort=False)<br>
df1.join(df2, lsuffix='_') - к одинаковым названиям прибавится суфикс '_'<br>
df = df1.set_index('key').join(df2.set_index('key')) - по одному индексу<br>
df1.join(df2.set_index('key'), on='key') - использовать столбец из df1<br><br>

<b>Merge</b><br>
Объеденить фрэймы; пересечение множеств (по умолчанию) inner; по левому (оно полностью останется и добавится из правого); правому и всё - outer. Объеденение по колонке с одинаковым названием (on="user_id") или задать (left_on, right_on)<br>
 
DataFrame.merge(self, right, how='inner', on=None, left_on=None, \
right_on=None, left_index=False, right_index=False, sort=False, \
suffixes=('_x', '_y'), copy=True, indicator=False, validate=None) <br>
df1.merge(df2, left_on='A', right_on='A1', how='inner')- из левого фрэйма 'A' \
<br><br>

<b>Concatenate</b><br>
pandas.concat(objs, axis=0, join='outer', join_axes=None, ignore_index=False, \
keys=None, levels=None, names=None, verify_integrity=False, sort=None, \
copy=True)<br>
pd.concat([df1, df2], sort=False, axis=0)<br>
df3 = pd.concat([df1, df2]) - сложились по столбцу<br>
df3 = pd.concat([df1, df2], axis=1) - получилось два столбца<br>

df1.update(df2)- у обоих df колонка с индексами и стобцы совпадают<br><br>

Среднее значение .mean()<br>
df_marks = pd.DataFrame(mydict)<br>
mean = df_marks.mean() ... среднее знач. по каждой колонке<br>
mean = df_marks.mean().mean() ... по всем колонкам<br>
mean = df_marks.mean(axis=1) ... по строкам<br>
print(pd.concat([df_marks['names'], mean], axis=1)) - столбецы 'name' + 'mean'<br>

extr = df['name_column'].str.extract(r"^(\d{4})", flag=0, expand=False)
   выбрали необходимое с помощью рег.выраж.<br><br>

for index, row in df.iterrows():<br>
    if row['date'] > 10:<br>
        print(row['date'])<br><br>
        
df = pd.DataFrame(np.random.rand(100000,2), columns=['a','b']) - тестовый df<br>
df.describe()<br>
fin=[] - сумма а и b<br>
for i,row in df.iterrows():<br>
    fin.append(row['a'] + row['b']) - медленно<br>
for i in range(len(df)):<br>
    fin.append(df['a'].loc[i]+df['b'].loc[i])<br>
for i in range(len(df)):<br>
    fin.append(df['a'].iloc[i]+df['b'].iloc[i])<br>
df.apply(lambda row: row['a']+row['b'], axis=1).to_list()<br>
for row in df.itertuples():<br>
    fin.append(row[1]+row[2])<br>
%timeit [a+b for a,b in zip(df['a'],df['b'])]<br>
(df['a'] + df['b']).to_list()<br>
%timeit (df['a'].values + df['b'].values).tolist() - быстро<br><br>

for col in df: - посчитать в % пустые значения в столбце<br>
    mis = np.mean(df[col].isnull())<br>
    print('{} - {}%'.format(col, round(mis*100)))<br>
med = df['name'].median() - заменить пустые знач на среднее<br>
df['name'] = df['name'].fillna(med)<br>

from pandas.plotting import scatter_matrix<br><br>

df.describe() - для колонок с числовыми данными count, mean, std, min, 25%, 50%, 75%, max по каждой колонке.<br>
df.describe(include='all') - для всех колонок.<br><br>

<b>Grouping and Aggregating</b><br>
contry_grp = df.groupby(['Country']) - DataFrameGroupBy object (по столбцу 'Contry').<br>
contry_grp.get_group('India') - df отсортирован по одной стране.<br>
contry_grp['SocialMedia'].value_counts().loc['India'] - посчитать сколько чел в Индии пользуются какими Media<br>

Поле по которому объеденяются фрэймы уходит в индекс;
column1_g = df.groupby('column1')['column2'].max() - для сводных таблиц; 1колонка - для которой формируем данные (или список колонок); 2колонка из которой берутся данные; и агрегативная ф-ция (count(), mean(), sum(), nunique(), min(), max())<br>
fst_pay = df_pay.groupby(['user', 'geo'])['pay_date'].min().reset_index() - группируем по двум столбцам и расчитываем дату первой оплаты, сбрасываем индекс.<br>
fst_pay = fst_pay.reset_index() можно отдельно<br><br>

Для грипировки по датам - колонка в формате datetime<br>
df['column'].groupby(df['date'].dt.month).nunique() - по месяцам(дням, годам)<br>

df['column'].agg(['count', 'mean', 'median']) - посчитать для колонки заданные ф-ции.<br>
df.agg({'column1': ['count', 'mean'], <br>
'column2': ['nunique']}) - посчитать для разных колонок<br><br>

Методы, которые принемают регулярные выражения: count(), replace(), contains(), extract(), findall(), match(), split(), rsplit()<br><br>

filt = df.date.str.contains('\w+', na=False) - возвращает булевые значения, пустые значения игнорировать.<br>
df.loc[filt] - df, соответствующие True<br>
df.loc[filt, 'km] = 300 - изменить значение в столбце km<br><br>

<b>.apply()</b><br>
user_info['type'] = user_info['temp'].apply(my_func) - к столбцу 'temp' применим ф-цию и сохраним р-т в новом столбце 'type'<br><br>

<i>def get_timestamp(y, m, d):</i><br>
&nbsp;&nbsp;&nbsp;&nbsp;<i>return dt.datetime.timestamp(dt.datetime(y, m, d))</i><br><br>

<i>def get_date(tmstmp):</i><br>
&nbsp;&nbsp;&nbsp;&nbsp;<i>return dt.datetime.fromtimestamp(tmstmp).date()</i><br><br>
  </section>

  <section id="s13"><h3 align="center">NumPy</h3>
<b>import numpy as np</b><br>
y = np.arange(3,12,3) == range(3,12,3); list(y)<br>
x = np.array([a*a for a in y])<br>
np.random.random(10) - 10 значений от 0 до 1<br>
  </section>

  <section id="s14"><h3 align="center">TeX</h3></section>
r"$x\ =\ \frac{\sqrt{144}}{2}\ \times\ (y\ +\ 12)$"<br>
r"$x^2; h_2O$"<br><br>
  </section>

  <section id="s15"><h3 align="center">pywin32</h3>
<i>pip install pywin32</i>; <b>import win32api</b> - модуль для работы с windows<br><br>

<i>pip install py32printing</i>; <b>import win32print</b> - вывод на принтер через windows<br>
  </section>

  <section id="s16"><h3 align="center">threating</h3>
<b>import threading</b> - многопоточный метод<br><br>

def take_a_nap():
&nbsp;&nbsp;&nbsp;&nbsp;time.sleep(5)<br>
&nbsp;&nbsp;&nbsp;&nbsp;print('Wake up')<br><br>

thread_obj = threading.Thread(target=take_a_nap, args=[], kwargs={})<br>
thread_obj.start()<br><br>

В качестве аргументов метод принемает название ф-ции, аргументы ф-ции, ключевые слова в качестве словаря (например: {'sep':';'} для ф-ции print)<br><br>

for thred in all_threads:<br>
&nbsp;&nbsp;&nbsp;&nbsp;tread.join() - чтобы все потоки завршили работу перед завершением работы ф-ции.<br>
print('Done')
  </section>

  <section id="s17"><h3 align="center">geocoder</h3>
<i>pip install geocoder</i>; <b>import geocoder</b><br><br>

city = geocoder.arcgis('city_name')<br>
print(sity.json)<br>
print(sity.json['lat'], sity.json['lng'])<br>
  </section>

  <section id="s18"><h3 align="center">SQLite</h3>
<p><a href="https://sqlitebrowser.org" target="_blank" rel="noopener" >DB Browser for SQLite</a><br>
<i>hot key:</i><br>
<i>Ctrl+Enter</i> - выполнить<br>
<a href="https://www.youtube.com/watch?v=TwnCXdCa8qg&list=PLA0M1Bcd0w8x4Inr5oYttMK6J47vxgv6J&index=1" target="_blank" rel="noopener" >SQLite (selfedo)</a><br>
<a href="https://youtu.be/K1C5JAo7cMU?si=dMn764dqVkZZvzRw" target="_blank" rel="noopener" >SQLite (Sweet Coder)</a></p>
<i>СУБД</i> - Система Управления Базой Данных (реляционные базы данных <i>relation</i>)<br>
<i>API</i> - Aplication Progamming Interface<br>
<i>execute(SQL)</i> - Structured Query Language<br><br>

<b>import sqlite3 as sq</b><br>
менеджер контекста автоматически подтвердит изменения(commit) и закроет соединение с базой.<br>
<i>with sq.connect("saper.db") as con:</i> - связь(создание) с файлом<br>
&nbsp;&nbsp;&nbsp;&nbsp;<i>cur = con.cursor()</i> - возвращает экземпляр класса 'Cursur'<br>
&nbsp;&nbsp;&nbsp;&nbsp;<i>cur.execute("""query""")</i><br><br>

<i>con.row_factory = sq.Row</i> - если добавить эту строчку вывод будет в виде словаря.<br><br>

другой способ через блок обработки исключений :<br>
con = None<br>
try: - соединение с базой<br>
except sq.Error as e:<br>
&nbsp;&nbsp;&nbsp;&nbsp;if con: con.rollback() - откатывает все изменения (перед загрузкой данных поставить ключевое слово BEGIN)<br>
&nbsp;&nbsp;&nbsp;&nbsp;print("Ошибка выполнения запроса")<br>
finally:
&nbsp;&nbsp;&nbsp;&nbsp;if con: con.close()<br><br>

<i>CREATE TABLE IF NOT EXISTS users (<br>
user_id INTEGER PRIMARY KEY AUTOINCREMENT,<br>
name TEXT NOT NULL,<br>
age INTEGER NOT NULL DEFAULT 1)</i> - создать табл users (в текущем каталоге), если с таким именем нет; поле user_id (с уникальными значениями, увеличивается на 1), поле name (тип данных-строка, дополнительно -  не может быть пустым); поле age (тип данных-целочисленное, по умолчанию не 0, значение=1); REAL-вещественное; BLOB-двоичные; UNIQUE, DEFAULT, NOT NULL, CHECK (age > 0 AND age &lt; 100)<br>
<i>rowid</i> - скрытое поле<br>
<i>cur.lastrowid</i> - какой id был присвоен в последней операции<br>
используем обратные кавычки, если название поля похоже на служебное слово.<br>
<i>DROP TABLE IF EXISTS name</i> - удалить таблицу с именем name<br><br>

<b>внесение, изменение, удаление записей</b><br>
<i>INSERT INTO users (name, gender, age, score) VALUES(Ivan, 1, 20, 1000)</i> - добавить в таблиццу; название полей (если все - можно не указывать; значения для ввода)<br>
<i>INSERT INTO users DEFAULT VALUES;</i> - столбцы, для которых определены значения  по умолчанию и нет NOT NULL, получат эти значения; остальные NULL<br>
<i>INSERT INTO users (name, age) VALUES</i><br>
<i>('Tom', 37), ('Bob', 34)</i> - добавить две строки<br>
Загрузить данные из коллекции (список кортежей); колелекция cars; поля - id INTEGER PRIMARY KEY AUTOINCREMENT, model, price.<br>
query = """INSERT INTO cars VALUES(NULL, ?, ?)"""<br>
for car in cars:<br>
&nbsp;&nbsp;&nbsp;&nbsp;cur.execute(query, car)<br><br>

<i>cur.executemany(query, cars)</i> - метод перебирает коллекцию.<br><br>

<i>query = """ UPDATE cars SET price = :Price WHERE model LIKE 'A%' """</i><br>
<i>cur.execute(query, {Price: 0})</i> - использование именованого параметра; имя параметра Price; и словарь со значениями для моделей начинающихся с A<br><br>

<i>query = """ DELETE FROM cars WHERE model LIKE 'A%';</i><br>
<i>UPDATE cars SET price = price=1000"""</i><br>
<i>cur.executescript(query)</i> - выполнить несколько команд (удалить все модели начинающиеся с 'А', а у остальных добавить 1000 к ценнику); с этим методом не используются шаблоны.<br><br>
<i>UPDATE users SET score = score+500, age=30  WHERE rowid = 1</i> (WHERE name LIKE 'Ivan'; <i>'_'</i> - любой символ, <i>'%'</i> - любое продолжение строки )<br>
<i>DELETE FROM users WHERE rowid IN(2,5)</i> - удалить записи 2 и 5<br><br>

<i>ORDER BY age</i> - сортировать по возростанию (ASC)<br>
<i>ORDER BY age DESC</i> - сортировать по убыванию<br>
<i>LIMIT max [OFFSET offset]</i> - выбрать столько строк [столько пропустить]<br>
<i>LIMIT offset, max</i> - тоже через зпт<br>
print(<i>cur.fetchall()</i>) - вывести результат (список кортежей)<br>
<i>fetchmany(size), fetchone()</i> - вывести определённое кол-во, одну запись<br>
или по строчно:<br>
<i>for result in cur</i><br>
&nbsp;&nbsp;&nbsp;&nbsp;print(result)<br>
print(cur.rowcount) - кол-во строк в таблице<br><br>

<b>изменение таблицы</b><br>
<i>ALTER TABLE users RENAME TO people</i> - переименовать таблицу<br>
<i>ALTER TABLE users ADD COLUMN email  TEXT NOT NULL</i> - добавим столбец с ограничением<br>
<i>ALTER TABLE users RENAME COLUMN email TO login</i><br>
<i>ALTER TABLE users DROP COLUMN login</i><br><br>

<b>фильтрация данных. WHERE</b><br>
<i>SELECT name, age, score FROM users</i>; (SELECT *) - выбрать всё<br>
<i>SELECT * FROM users WHERE score &lt; 1000</i> - выбрать всё где <i>score</i> &lt; 1000<br>
<i>SELECT * FROM users WHERE score BETWEEN 500 AND 1000</i> - числа включены<br>
<i>SELECT * FROM users WHERE name LIKE 'Ivan'</i><br>
приоритет: NOT, AND, OR<br>
<i>SELECT name, prod_count * price AS total_sum FROM products</i> - в таблице есть три поля; выбрать поле name и поле, которое будет содержать  произведение двух других полей с новым названием<br>
<i>SELECT rowid,* FROM users</i> - показать поле rowid <br><br>

<b>Агрегирование и группировка GROUP BY</b><br>
<i>SELECT count(user_id) FROM users WHERE user_id = 1</i> - кол-во строк с user_id = 1<br>
<i>SELECT count(user_id) as count FROM users WHERE user_id = 1</i> - выбрать синоним (alias) для поля (чтобы не выводилось count(user_id))<br>
<i>count(), sum(), avr(), min(), max()</i> - кол-во, сумма, среднее арифетическое, минимальное и максимальное значения.<br>
<i>DISTINCT</i> - уникальные значения<br>
<i>SELECT count(DISTINCT name) as names FROM users</i><br><br>

<i>SELECT user_id, sum(score) as sum</i> - выбираем поле user_id, подсчитываем сумму очков для каждого игрока, название  для созданного поля sum<br>
<i>FROM usrs</i><br>
<i>CROUP BY user_id</i><br><br>

<b>JOIN</b><br>
<i>SELECT name, gender, games.score FROM games</i><br>
<i>JOIN users ON games.user_id=users.rowid</i> - условие связывания: внешний ключ = первичному ключу<br>
<i>LEFT JOIN</i> - возьмёт левую таблицу полностью и даже если нет соответствий  с правой.<br><br>

<b>UNION</b> - объеденит толлько уникальные записи<br>
<i>SELECT name1, name2 FROM table1</i><br>
<i>UNION SELECT name3, name4 FROM table2</i><br><br>

<b>загрузка картинок в таблицу</b> (кактинки в папке 'avas'; 1.png, 2.png...; в созданной таблице user_img поля id, name, ava BLOB)<br>
<i>def readAva(n):</i><br>
&nbsp;&nbsp;&nbsp;&nbsp;<i>try:</i><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<i>with open(f"avas/{n}.png", 'rb') as f:</i><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<i>return f.read()</i><br>
&nbsp;&nbsp;&nbsp;&nbsp;<i>except IDError as e:</i><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<i>print(e)</i><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<i>return False</i><br><br>

<i>img = readAva(1)</i><br>
<i>if img:</i><br>
&nbsp;&nbsp;&nbsp;&nbsp;<i>binary = sq.Binary(img)</i><br>
&nbsp;&nbsp;&nbsp;&nbsp;<i>query = """INSERT INTO users VALUES (NULL, 'Joe', ?)"""</i><br>
&nbsp;&nbsp;&nbsp;&nbsp;<i>cur.execute(qyery, (binary,))</i><br><br>

<b>сохранение картинки из таблицы в cwd</b><br>
<i>def writeAva(name, data):</i><br>
&nbsp;&nbsp;&nbsp;&nbsp;<i>try:</i><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<i>with open(name, 'wb') as f:</i><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<i>f.write(data)</i><br>
&nbsp;&nbsp;&nbsp;&nbsp;<i>except IDError as e:</i><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<i>print(e)</i><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<i>return False</i><br>
&nbsp;&nbsp;&nbsp;&nbsp;return True<br><br>

(db.row_factory = sq.Row) - добавим метод, чтобы вызывать название поля как ключ словаря<br>
<i>cur.execute("""SELECT ava FROM user_img LIMIT 1""")</i><br>
<i>img = cur.fetchone()['ava']</i><br>
<i>writeAva("name.png", img)</i> - записали изображение в cwd  как 'name.png'<br><br>

<b>Дата и время</b><br>
<i>SELECT</i><br>
<i>date(time-value, modifier, modifier,..) AS date</i>,<br>
<i>time() AS time</i>,<br>
<i>datetime() AS datetime,</i><br>
<i>datetime(1092941466),</i> - дней с начала юлианской эпохи (INTEGER или REAL)<br>
<i>julianday() AS julian,</i> - дней с начала юлианского периода (24 ноября 4714 до н.э.)<br>
<i>strftime(format, time-valum, modifier, modifier..)</i><br><br>

Если не передаются параметры (или стоит 'now'), то они возвращают текущие дату и время.<br>
<i>YYYY-MM-DD HH:MM:SS.SSS</i> - параметр time-value, может между датой и временем быть разделитель 'T'<br>
модификаторы:<br>
<i>SELECT date('now', '-2 days', '1 months', '3 hours', '35 miutes', '-45.1 seconds', '11 years'),</i> - к текущей дате прибавить месяц, отныть 2 дня..<br>
<i>'start of month', 'start of year', 'start of day'</i> - вернуть в начало месяца, года, дня<br>
<i>'weekday 0', 'weekday 1'..</i> - сдвинуть на воскр, понедельник..<br>
<i>unixepch</i> - возвращает кол-во секунд с эпохи  UNIX (только с форматом 'DDDDDDDDDD')<br>
<i>localtime</i> - местное время<br>
<i>uts</i> - UTC<br><br>
<i>Форматирование дат и времени</i>
<table>
  <tr><td>%d</td><td> - день месяца в формате 00</td></tr>
  <tr><td>%f</td><td> - секунды в формате  SS.SSS</td></tr>
  <tr><td>%H</td><td> - час в формате 00-24</td></tr>
  <tr><td>%j</td><td> - день года в формате 001-366</td></tr>
  <tr><td>%J</td><td> - дней с начала юдианской эпохи</td></tr>
  <tr><td>%m</td><td> - месяц в формате 01-12</td></tr>
  <tr><td>%M</td><td> - минута в формате 00-59</td></tr>
  <tr><td>%s</td><td> - секунд с 1970-01-01</td></tr>
  <tr><td>%S</td><td> - секунды в формате 00-59</td></tr>
  <tr><td>%w</td><td> - день недели в формате 0-6 (0 - вск)</td></tr>
  <tr><td>%W</td><td> - номер недели года в формате 00-53</td></tr>
  <tr><td>%Y</td><td> - год в формате 0000-9999</td></tr>
  <tr><td>%%</td><td> - экранирует символ '%'</td></tr>
</table>
<i>SELECT strftime('%d.%m.%Y', '2021-12-01');</i> - 01.12.2021<br><br>

сохранять дату можно с типом TEXT,<br>
или с типом  REAL - тогда будет сохранено кол-во дней с начала юлианской эпохи.<br>
<i>SELECT date_time,  datetime(date_time) FROM users</i> - поле date_time сохранено с типом REAL, второе поле возвращает обычную дату<br><br>

сохранение даты в виде timestemp<br>
def get_timestamp(y, m, d):<br>
&nbsp;&nbsp;&nbsp;&nbsp;return dt.datetime.timestamp(dt.datetime(y, m, d))<br><br>

def get_date(tmstmp):<br>
&nbsp;&nbsp;&nbsp;&nbsp;return dt.datetime.fromtimestamp(tmstmp).date()<br><br>

<b>Создание бэкапа БД</b><br>
открываем  БД; записываем её в файл 'sql_damp.sql'<br>
with sq.connect("cars.db") as con:<br>
&nbsp;&nbsp;&nbsp;&nbsp;cur = con.cursor()<br><br>

&nbsp;&nbsp;&nbsp;&nbsp;with open('sql_damp.sql', 'w') as f:<br>
&nbsp;&nbsp;&nbsp;&nbsp;for sql in con.iterdump():<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;f.write(sql)<br><br>

Для восстановления БД открываем файл 'sql_damp.sql' для чтения; и запускаем executescript()<br>
sql = f.read()<br>
cur.executescript(sql)<br>
  </section>

  <section>
import string; string.ascii_letters<br><br>

pip install faker; import faker; fake = faker.Faker(); fake.name() - произвоьное имя<br>
[fake.name for i in range(15)]<br><br>
  </section>
      </aside>
    </div>
  </div>
</body>
</html>