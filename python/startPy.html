<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <link rel="stylesheet" href="../css/style1.css" />
  <title>startPy</title>
</head>

<body>
<div class="cont">
  <nav class="menu">
    <ul class="menu_list">
      <li><a href="../index.html"><img src="../img/icon-home.png" alt="home"></a></li>
      <li>
        <span>Python</span>
        <ul class="sub_menu_list">
          <li><a href="./startPy.html">startPy</a></li>
          <li><a href="./libraryPy.html">libraryPy</a></li>
          <li><a href="./dir_and_file.html">Папки и файлы</a></li>
          <li><a href="./pictures.html">Картинки и графики</a></li>
          <li><a href="./web_scraping.html">Web scraping</a></li>
          <li><a href="./flask.html">Flask</a></li>
          <li><a href="./django.html">Django</a></li>
          <li>Искуственный интелект</li>
        </ul>
      </li>
      <li>
        <span>Frontend</span>
        <ul class="sub_menu_list">
          <li><a href="../frontend/html.html">HTML</a></li>
          <li><a href="../frontend/css.html">CSS</a></li>
          <li><a href="../frontend/js.html">JavaScript</a></li>
          <li><a href="../frontend/jsDom.html">JavaScript DOM</a></li>
        </ul>
      </li>
      <li>
        <span>Books</span>
        <ul class="sub_menu_list">
          <li><a href="../books/english.html">Books in English</a></li>
          <li><a href="../books/math.html">Математика</a></li>
          <li><a href="../books/environment.html">Окружение</a></li>
          <li><a href="../books/digest.html">Справочники</a></li>
        </ul>
      </li>
    </ul>
  </nav>

    <div class="left_right">
      <aside class="left">
<p><a href="#s1">Введение</a></p>
<p><a href="#s2">Числа</a></p>
<p><a href="#s3">Строки</a></p>
<p><a href="#s4">Список</a></p>
<p><a href="#s5">Словарь</a></p>
<p><a href="#s6">Кортеж</a></p>
<p><a href="#s7">Set</a></p>
<p><a href="#s8">Exception</a></p>
<p><a href="#s20">Ссылки</a></p>            
        </aside>

        <aside class="right"><h1 align="center" id="s0">Python.</h1>
    <section id="s1"><h3>Введение:</h3>
PEP8 - python enhancement proposal<br>
ASCII - кодовая таблица.<br>
Всё в Python - объекты (экземпляры классов, а класс - шаблон(прототип) для создания объектов)<br>
У всех объектов есть атрибуты; атрибут называется методом, если его значение - ф-ция;<br>
Первая строка файла "shebang" line - <i>#! python</i><br>
По умолчанию все исходные файлы обрабатываются  в UTF-8.
Для другой кодировки во второй строке объявляем:<br>
<i># -*- coding: cp1252 -*-</i>  (например Windows-1252)<br>
# - hash character - используется для комментариев.<br><br>

expressions (выражения) - результат - значение.<br>
statements (инструкции) - выполняют действие (def, if, elif, else, while, break, continue, pass, for in, match, импортирование модуля).<br><br>

<i>match some_expr:</i><br>
&nbsp;&nbsp;&nbsp;&nbsp; case 1:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; print('in this case')<br>
&nbsp;&nbsp;&nbsp;&nbsp; case 2:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; print('in that case')<br>
&nbsp;&nbsp;&nbsp;&nbsp; case _:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; print('other')<br><br>

<b>переменные</b> начинаются с буквы или символа подчёркивания (A-z, 0-9, _)<br>
x, y, z = 'Orange', 'Banana', 12 + 5 - присвоить значения трём переменным (multiple assignment).<br>
Используем нижнее подчёркивание в качестве переменной и *_ в качестве переменной для остальных значений.<br>
year, month, *_ = [2023, 7, 15, 20, 54]<br>
global x - используем ключевое слово, чтобы создать глобальную переменную внутри ф-ции.<br>
snake_case - переменные, ф-ции, методы, модули<br>
PascalCase - классы<br>
DB_PASSWORD - константы<br><br>

<b>основные типы в Python:</b><br>
str, int, float, complex (числовые), bool (логический) - True | False, list, tuple, range (последовательности), dict (отображение), set, frozenset (типы наборов), bytes, bytearray, memoryview (бинарные)<br>
type(x) - тип данных в x<br><br>

False - 0; 0.0; 0j; False; None; dict(); list(); tuple();set set(); range range(0); str"""

<b>встроенные ф-ции:</b><br>
print([,end=','][,sep=','][file=None]); в качестве аргумента передаём значение типа str<br>
input('enter your name: ')<br>
ф-ция dir('name') - возвращает атрибуты объектов (здесь методы для str).<br>
dir(__builtins__) - список встроенных ф-ций (двойные подчёркивания - системные атрибуты или магические методы)<br>
print(id(name)) - адрес объекта с именем name; цифры<br><br>

<i>yield</i><br><br>

<b>функция</b> &lt;class 'function'><br>
<i>def my_fn(a,b): </i>//ф-ция; имя; параметры (при вызове - аргументы)<br>
""" Инфо о ф-ции. Вызывается my_fn.__doc__"""<br>
 &nbsp;&nbsp;&nbsp;&nbsp; <i>c = a + b </i> //тело ф-ции<br>
 &nbsp;&nbsp;&nbsp;&nbsp; <i>return c </i> //ключевое слово для возврата рез-та<br><br>

 Имя ф-ции можно присвоить другой переменной:<br>
 other_name = my_fn<br>
 other_name() - вызов ф-ции<br><br>

 my_fn() - вызов функции (без аргументов; с позиционными аргументами; с кортежем из любого ко-ва позиционных аргументов (*arg); перебирать эти элементы можно по индексу(arg[1], arg[2]); ключевые слова (a='Bob', b=23); с аргум и их знач в виде словаря (**person))<br><br>

<i>def my_fn(**person):</i><br>
&nbsp;&nbsp;&nbsp;&nbsp; info = f"{person.get('name')} wrote {person['qty']} storis" // если ключа 'name' нет вернёт None<br>
&nbsp;&nbsp;&nbsp;&nbsp; return info<br><br>

<i>def my_fn(value, multiplier=1):</i> ф-ция со значением по умолчанию<br>
если при вызове ф-ции будет дан один аргумент, то значение второго по умолчанию; вторым параметром может быть ф-ция:<br><br>

<i>def get_weekday():</i><br>
&nbsp;&nbsp;&nbsp;&nbsp; return date.today().strftime('%A')<br><br>

<i>def create_new_post(post, weekday= get_weekday()):</i><br>
&nbsp;&nbsp;&nbsp;&nbsp; post_copy = post.copy()<br>
&nbsp;&nbsp;&nbsp;&nbsp; post_copy['created_on_weekday'] = weekday<br>
&nbsp;&nbsp;&nbsp;&nbsp; return post_copy - вернёт копию поста с новым ключом<br><br>

info = my_fn(name='Bob', qty=20)<br>
print(info)<br><br>

<i>колбэк ф-ции</i><br>
<i>def process_num(num, collback_fn):</i><br>
&nbsp;&nbsp;&nbsp;&nbsp; collback_fn(num)<br><br>

 <i>pass</i> - самая короткая ф-ция (ничего не делать)<br>
 если в качестве аргумента передаётся неизменяемый тип, то меняется он только в ф-ции; если изменяемый тип - изменится и внешняя переменная  <br><br>

 <i>docstring</i> - описание ф-ции и параметров в теле ф-ции; распологается в тройных ковычках; в vs code расширение autoDocstring(поставить ковычки; выбрать автоматическое описание)<br><br>

 <b>диапазон &lt;class 'range'>:</b><br>
 my_range = range([start],stop[,step]) от(вкл, inclusive) до(не вкл, exclusive)<br>
 my_range[0] - элемент по индексу<br>
 list(range(10)) ..[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]<br>
 my_range.index(3) - индекс числа 3<br>
 my_range.count(3) ..1 - или 1 или 0 (нет таких)<br>
 <i>sum</i>(range(4)) .. 6<br><br>

 <b>zip - &lt;class 'zip'>:</b><br>
fruits = ['apl', 'ban', 'lime']; qnt = range(1, 4); str1 = 'abc'<br>
new_zip = zip(fruits, qnt, str1)<br>
print(list(new_zip)) .. [('apl', 1, 'a'), ('ban', 2, 'b'), ('lime', 3, 'c')]<br>
new_dict = dict(new_zip) - если в new_zip два элемента можно его конвертировать в словарь<br>
new_dict = {k:v for k,v in zip(gnt, fruits)}<br>
    </section>

    <section id="s2"><h3>Числа (numbers):</h3>
Экземпляры классов '&lt;class 'int'>, &lt;class 'float'>, &lt;class 'complex'>; неизменяемый тип;<br>
x = 12; y = 12; print(id(x)) // адрес в памяти у x и y и id(12) - один<br>
x = y - копия y; изначально один id; если изменять y - x не изменится, а у y изменится id<br><br>

/ - деление; возвращает с дробной частью<br>
// - деление; возвращает целое число (-7 // 2 .. -4)<br>
% - возвращает остаток от деления (-7 % 2 .. -1)<br>
** - возведение в степень (to the power of)<br>

_ - в интерактивном режиме последнее значение присваеватся переменной _<br>
1_000_000 - сдесь подчёркивание для удобства<br>
a,b = 10, 'word' - множественное присвоение<br><br>

<i>list(range(1,20,2))</i> - список от 1 до 20(невкл), шаг 2<br>
for i in range(20):<br>
&nbsp;&nbsp;&nbsp;&nbsp; print(i)<br><br>

abc(-5) .. 5<br>
min(1,2,7,-3) .. -3; max(1,2,7,-3) .. 7<br>
pow(10, 2) // 100; pow(27, 1/3) .. 3<br>
int(5.8) .. 5<br>
<i>round(number [,ndigits=None])</i> - округление с точностью до.<br><br>

<i>math</i><br>
math.ceil(5.2) .. 6; math.ceil(-5.2) .. -5<br>
math.floor(5.2) .. 5; math.floor(-5.2) .. -6<br>
math.sqrt(49) .. 7; math.pow(2, 3) ..8<br>
math.pi; math.e<br><br>

a, b = map(float, input().split()) - ввести два числа; преобразовать тип и присвоить их знач. переменным<br>

<b>Форматирование чисел: format()</b><br>    
    </section>

    <section id="s3"><h3>Строки (string):</h3>
Экземпляры класса  &lt;class 'str'>; неизменяемый тип;<br>
данные заключённые в кавычки, двойные ковычки или тройные (для многострочной строки); \ - обратный слеш может использоватся для экранирования ковычек внутри строки, а в многострочных строках поможет не пропускать первую строку.<br>
строки могут быть склеены + и повторятся с помощью *; зпт между строками (в prin) - добавит пробел.<br>
print(r'C:\some\name')- сырая строка (row string)<br><br>  

string = 'What a beautiful world!'<br><br>

<i>string[0, 4] (string[:4])</i> - срез от(вкл) до (невкл)<br>
<i>string[-3:]</i> - последние три знака.<br>
<i>string[::-1]</i> - задать шаг (вся строка в обратном порядке)<br>
<i>string[3::2]</i> - с третьего символа через два.<br>
<i>string[3:3+5]</i> - с третьего + 5<br>
'world' <i>in</i> string .. True<br>
'world' <i>not in</i> string .. False<br>
<i>len(string)</i> - длина строки.<br> 
<i>string.count('a',[start],[end])</i> - кол-во знаков 'a'<br>
<i>string.find('a'[,start][end])</i> - индекс или -1, если нет совпадений.<br>
<i>string[0]</i> - первый знак по индексу; <i>string[-1]</i> - последний.<br>
<i>.replace(old, new[,maxcount])</i> (удалить - заменить на '') <br>
<i>.isalpha()</i> - только буквенные (знаки препинания и пробелы не буквы)<br>
<i>.isdigit()</i> - только цифры (минус и точка не цифры)<br>
<i>.isalnum()</i> - только буквы и цифры<br>
.upper(), .lower(), .capitalize(), .title(), <br>
.strip([chars]) - удаление пробельных (или других) символов с обеих сторон; символы в любом порядке; удалятся и повторения .rstrip(), lstrip(),<br>
.index(str,[sart],[end])<br>
.islower(), .isupper(), .isspace(), istitle(), .startswith(str), .endswith(str)<br>
(' ').join(список) - вернёт строку из списка строк<br>
<i>string.split(символ)</i> - вернёт список по разделителю (без аргумента - по пробелам)<br>
.partition(шаблон) - вернёт список из трёх элементов; можно использовать множественное присвоение: before, sep, after = string.partition('word')<br>
('11').zfill(width) - кол-во знаков; добавит 0 в начале<br>
ord(символ) - символ в код, chr(число) - из кода в символ<br>
.format(*args, **kwargs)<br><br>

string.rjust(width[,fillchar='']) - (string.rjust(30, '*')) по умолчанию пробелы<br>
string.ljust(width[,fillchar=''])<br>
string.center(width[,fillchar=''])<br>

<b>Форматирование строк:</b>
r"C:\My Doc\try.py" - сырая строка (row string)<br>
f"just string {varible}"<br>
"my name %s, my age %s"%(name, age)<br>

    </section>

    <section id="s4"><h3>Список (list):</h3>
Экземпляры класса  &lt;class 'list'>; изменяемый тип (mutable);<br>
list1 = [1, 4, 9, 16, 25]; list2 = [23, 12]; a = 'abcd'<br>
first = list1[0]; second = list1[2]<br>
one, two = list2 - множественное присвоение (multiple)<br>
<i>in</i>; <i>not in</i> - возвращает булевое значение<br>
print(list(a)) .. ['a','b','c','d']; <i>len</i>(list1) .. 5 - длина списка<br>
list[start:end:step] - срез<br>
list1[0] .. 1; list1[-1] .. 25; list1[:] .. весь список; list1[1:3] .. [4,9]; list1[3:] .. [16, 25]; list1[:3] .. [1,4,9]; list1 + list2..[1,4,9,16,25,23,12] - сложить два списка<br>
list2 = list1[:] - присвоить list2 копию list1<br>
list2 = list1.<i>copy()</i> - копию можно менять независимо от оригинала, если нет вложенных изменяемых типов или надо импортировать модуль (from copy import deepcopy).<br>
<i>del list1[1]</i> - удалить элемент с индексом 1<br>
x = [list1, list2]; x .. [[1, 4, 9, 16, 25], [23, 12]] - список списков<br>
x[0][1] .. 4 - индексация по списку списков<br>
list1[0] = 5 .. [5,4,9,16,25] - присвоить значение по индексу.<br>
list1[1:4] = [7,8,9] .. [5,7,8,9,16,25] - присвоить по срезу.<br>
list1[1:4] = [] .. удалить элементы по срезу; list1[:] = [] .. очистить список<br>
list1<i>.append(36)</i> | list1<i>.append(6**2)</i> .. [5,4,9,16,25,36]<br>
<i>.pop() </i>- удалит последний элемент списка и вернёт его.<br>
<i>.pop(2)</i> - удалит и вернёт элемент с индексом '2'<br>
<i>.remove('item')</i> - удалить значение из списка.<br>
<i>.sort([reverse=True][key=str.lower])</i> - по умолчинию (без аргумента) сортирует по возростанию.<br>
<i>.reverse()</i> возвращает None; перевернёт на месте<br>
<i>.count(el)</i> - кол-во el в списке.<br>
<i>.insert(2, el)</i> - вставить el перед индесом 2<br>
<i>clear()</i> - очистить список<br>
<i>.extend('abc')</i> - в список добавятся 'a','b','c'<br>
<i>min</i>(list1); <i>max</i>(list1); <i>sum</i>(list1) - минимальное, максимальное значение списка; сумма всех элементов.<br><br>

for index, item in enumerate(list):<br>
&nbsp;&nbsp;&nbsp;&nbsp; print(f'Index {index} item - {item})<br><br>

<i>random.choice(list1)</i> - вернёт случайное знач из списка<br>
<i>random.shuffle(list)</i> - перемешает на месте<br><br>

squares = list(map(lambda x: x**2, range(10)))<br>
squares = [x**2 for x in range(10)]<br><br>

[(x, y) for x in [1,2,3] for y in [3,1,4] if x != y]<br>
[(1, 3), (1, 4), (2, 3), (2, 1), (2, 4), (3, 1), (3, 4)]<br><br>

freshfruit = ['  banana', '  loganberry ', 'passion fruit  ']<br>
[weapon.strip() for weapon in freshfruit]<br>
['banana', 'loganberry', 'passion fruit']<br><br>

vec = [[1,2,3], [4,5,6], [7,8,9]]<br>
[num for elem in vec for num in elem]<br>
[1, 2, 3, 4, 5, 6, 7, 8, 9]<br>
    </section>

    <section id="s5"><h3>Словарь (dictionary):</h3>
Экземпляры класса  &lt;class 'dict'>; изменяемый тип (mutable);<br>
Содержит пары ключ: значение; разделены зпт; порядок не имеет значения; ключи уникальны; если задать ключ с таким же назвнием он перезапишится.<br>
(print(my_car.__doc__)) - документация<br>
my_car = {<br>
    &nbsp;&nbsp;&nbsp;&nbsp; 'brend': 'Solaris',<br>
    &nbsp;&nbsp;&nbsp;&nbsp; 'price': 1000,<br>
}    <br>

my_car = dict(brend='Solaris', price=1000)<br>
my_car = dict(список списков или кортежей)<br><br>

my_car['brend'] - вызов значения по ключу; присвоение нового значения или добавить новую пару.<br>
В качестве значения может быть вложенный словарь. Тогда доступ к значению будет например: car['brend']['price']<br>
В  качестве ключей и значений могут быть переменные. Тогда ковычки не нужны<br>
<i>len(my_car)</i> - длина словаря<br>
<i>del my_car['price']</i> - удалить пару.<br>
<i>my_car.get('brend')</i> - получить значение по ключу (при его отсутствии в словаре не вызовет ошибку, а вернёт None)<br>
<i>my_car.get('qty', 0)</i> - значение по умолчанию (если ключа нет)<br>
<i>my_car.setdefault('color', 'blue')</i> - добавить в словарь ключ, если такого нет, со значением.( если есть не изменит)<br>
<i>my_car2 = my_car.copy()</i> независимаая копия словаря.<br>
<i>my_car.items()</i> - список кортежей ('ключ', знач); класс dict_items<br>
<i>list(my_car.items())</i> - в обычный список<br>
<i>my_car.keys()</i> - список ключей; класс dict_keys<br>
<i>my_car.values()</i> - список значений; класс dict_values<br>
my_car2 = my_car.copy() - вложенные словари и списки будут ссылатся на один адрес памяти (кортежи, строки - нет); shallow copy (поверхносная); для глубокого копирования используем модуль <i>from copy import deepcopy</i><br>
Не рекомендуется изменять оригинал; вместо этого создаём внутри ф-ции копию, или другой объект.<br>
<i>for user, status in users.copy().items():</i><br>
dict1 | dict2 - сложить два словаря(одинаковые ключи войдут один раз(последний); вернёт сложенный словарь)<br>
dict1.update(dict2) - сложить и сохранить в dict1<br>
import pprint<br>
pprint.pprint(users) - распечатать красиво<br>
    </section>

    <section id="s6"><h3>Кортеж (tuple):</h3>
my_tuple = ('one', 2, True)<br>
&lt;class 'tuple'>; не изменяемый тип (не изменить, не удалить); порядок элементов важен; методы: len(), count(), index(Any,[,start][,stop]) - длина кортежа, посчитать кол-во элементов и индекс конкретного элемента.<br>
можно конвертировать кортеж в список, сделать изменения и конвертировать его обратно в кортеж; list(my_tuple); tuple(my_list)<br>
tuple('abcd'); tuple(dict()) - кортеж из любых итерируемых объектов.<br>
Кортеж из словарей: my_tuple = ({'id': 123, 'name': 'Al'}, {'id': 321, 'name': 'Bob'})<br>
my_tuple[0]['id'] = 567 - данные словарей можно изменить<br>
tuple1 + tuple2 - один кортеж, состоящий из двух<br>
my_tuple.index('one') ..0<br>
my_tuple.count('one') ..1<br>
    </section>

    <section id="s7"><h3>Set:</h3>
my_set = {'apple', 'banana', ' lime'} &lt;class 'set'>; <br>
Набор - неупорядоченая последовательность элементов; содержит только уникальные элементы (обычно одного типа); в set не добавить список или словарь, но кортеж можно (неизменяемыый тип)<br>
set() - создать пустой набор<br>
методы наборов:<br>
my_set.add('chery') - добавить элемент<br>
my_set.remove('chery') - удалить элемент(если его небыло error)<br>
my_set.discard('chery') - удалить элемент(не вызовет обшибки)<br>
set3 = my_set.union(set2); my_set | set2 - объединеие двух наборов (одинаковые элементы один раз)<br>
set3 = my_set.intersection(set2) - пересечение множеств (аргумент - любой итерируемый объект 'abcd') (оператор &)<br>
my_set.issubset(set2) .. False - является ли подмножеством?<br>
my_set.issuperset(set2) .. True - включает ли в себя?
set3 = my_set.symmetric_difference(set2) - элементы, которые не пересекаются<br>
print((a | b) - (a & b)) - объеденить два множества и вычесть из него пересечение этих множеств<br>
set3 = my_set.difference(set2)
set3 = set2.copy() - скопировать сет<br>
clear,update,pop<br>
    </section>

    <section id="s8"><h3>Обработка исключений (Exception handling):</h3>
raise Exception("This is the error massage")<br>
try: ...; except Exception as err: print(str(err))<br>
import sys<br>
try: (блок кода)<br>
except KeyboardInterrupt:<br>
&nbsp;&nbsp;&nbsp;&nbsp; sys.exit() // Ctrl + c - останов программы без выброса ошибки.<br><br>
finally:<br><br>

<i>assert</i> условие, 'коментарий'<br><br>

<i>ZeroDivisionError</i><br>
<i>KeyboardInterrupt</i><br>
<i>Invalid argument</i><br>
    </section>

        </aside>

    </div>
<footer><h3 id="s20">Ссылки:</h3>
    <p><a href="https://docs.python.org/3/tutorial/introduction.html" target="_blank" rel="noopener" >The Python Tutorial</a> - Python 3.11.4 documentation</p>
    <p><a href="http://automatetheboringstuff.com/2e/chapter1/" target="_blank" rel="noopener" >automatetheboringsruff</a> - AlSweigart</p>
    <p><a href="https://proproprogs.ru/index.php" target="_blank" rel="noopener" >proproprogs</a> - Про программирование</p>
</footer>
</div>  
</body>
</html>